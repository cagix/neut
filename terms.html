<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Terms - Neut Programming Language</title>
    <meta name="description" content="A dependently-typed programming language with static memory management." />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="css/general.css" />
    <link rel="stylesheet" href="highlight.css" />
    <meta property="og:title" content="Terms - Neut Programming Language" />
    <meta property="og:description" content="A dependently-typed programming language with static memory management." />
    <meta property="og:url" content="https://vekatze.github.io/neut/terms.md" />
    <meta property="og:type" content="article" />
  </head>
  <body>
    <div id="body-container">
      <header id="menu-bar">
        <h1 class="menu-title">
          <a href="overview.html">
            Neut Programming Language
          </a>
        </h1>

        <div class="right-buttons">
            <a href="https://github.com/vekatze/neut" class="menubar-item">
              <span>GitHub</span>
            </a>
        </div>
      </header>
      <div id="content-box">
        <aside id="sidebar">
          <nav class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-external-world.html"><strong aria-hidden="true">3.1.</strong> Hello External World</a></li><li class="chapter-item expanded "><a href="programming-in-neut.html"><strong aria-hidden="true">3.2.</strong> Programming in Neut</a></li><li class="chapter-item expanded "><a href="static-memory-management.html"><strong aria-hidden="true">3.3.</strong> Static Memory Management</a></li></ol></li><li class="chapter-item expanded "><a href="language-reference.html"><strong aria-hidden="true">4.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">4.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">4.3.</strong> Statements</a></li><li class="chapter-item expanded "><a href="terms.html" class="active"><strong aria-hidden="true">4.4.</strong> Terms</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">4.5.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basis.html"><strong aria-hidden="true">4.6.</strong> Basis</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-next.html"><strong aria-hidden="true">5.</strong> What is Next?</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="manual-installation.html"><strong aria-hidden="true">6.</strong> Manual Installation</a></li><li class="chapter-item expanded "><a href="development-environment.html"><strong aria-hidden="true">7.</strong> Development Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lovely-lsp-showcase.html"><strong aria-hidden="true">7.1.</strong> Lovely LSP Showcase</a></li><li class="chapter-item expanded "><a href="rapid-prototyping.html"><strong aria-hidden="true">7.2.</strong> Rapid Prototyping</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">7.3.</strong> Editor Setup</a></li></ol></li><li class="chapter-item expanded "><a href="how-to-execute-types.html"><strong aria-hidden="true">8.</strong> How to Execute Types</a></li><li class="chapter-item expanded "><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
          </nav>
        </aside>

        <main id="content" tabindex="0">
          <article id="content-inner">
            <h1 id="terms"><a class="header" href="#terms">Terms</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<h3 id="basics"><a class="header" href="#basics">Basics</a></h3>
<ul>
<li><a href="#tau">tau</a></li>
<li><a href="#local-variables">Local Variables</a></li>
<li><a href="#top-level-variables">Top-Level Variables</a></li>
<li><a href="#let">let</a></li>
</ul>
<h3 id="primitive-value"><a class="header" href="#primitive-value">Primitive Value</a></h3>
<ul>
<li><a href="#integers">Integers</a></li>
<li><a href="#floats">Floats</a></li>
<li><a href="#texts">Texts</a></li>
</ul>
<h3 id="function"><a class="header" href="#function">Function</a></h3>
<ul>
<li><a href="#x1-a1--xn-an---b">(x1: a1, ..., xn: an) -&gt; b</a></li>
<li><a href="#function-x1-a1--xn-an--e-">function (x1: a1, ..., xn: an) { e }</a></li>
<li><a href="#define-fx1-a1--xn-an-c--e-">define f(x1: a1, ..., xn: an): c { e }</a></li>
<li><a href="#ee1--en">e(e1, ..., en)</a></li>
<li><a href="#e-of-x1--e1--xn--en">e of {x1 = e1, ..., xn = en}</a></li>
<li><a href="#exact-e">exact e</a></li>
</ul>
<h3 id="adt"><a class="header" href="#adt">ADT</a></h3>
<ul>
<li><a href="#adt-formation">ADT Formation</a></li>
<li><a href="#constructors-adt-introduction">Constructors</a></li>
<li><a href="#match">match</a></li>
</ul>
<h3 id="noema"><a class="header" href="#noema">Noema</a></h3>
<ul>
<li><a href="#case">case</a></li>
<li><a href="#a">&amp;a</a></li>
<li><a href="#on">on</a></li>
<li><a href="#e">*e</a></li>
</ul>
<h3 id="flow-and-channel"><a class="header" href="#flow-and-channel">Flow and Channel</a></h3>
<ul>
<li><a href="#flow">flow</a></li>
<li><a href="#detach">detach</a></li>
<li><a href="#attach">attach</a></li>
<li><a href="#new-channel">new-channel</a></li>
</ul>
<h3 id="miscs"><a class="header" href="#miscs">Miscs</a></h3>
<ul>
<li><a href="#magic">magic</a></li>
<li><a href="#introspect">introspect</a></li>
<li><a href="#admit">admit</a></li>
<li><a href="#assert">assert</a></li>
<li><a href="#_">_</a></li>
</ul>
<h3 id="syntax-sugar"><a class="header" href="#syntax-sugar">Syntax Sugar</a></h3>
<ul>
<li><a href="#use-e-x1--xn-in-cont">use e {x1, ..., xn} in cont</a></li>
<li><a href="#ex">e::x</a></li>
<li><a href="#if">if</a></li>
<li><a href="#when-cond--e-">when cond { e }</a></li>
<li><a href="#e1-e2">e1; e2</a></li>
<li><a href="#try-x--e1-in-e2">try x = e1 in e2</a></li>
<li><a href="#tie-x--e1-in-e2">tie x = e1 in e2</a></li>
<li><a href="#t">?t</a></li>
<li><a href="#e1--en">[e1, ..., en]</a></li>
<li><a href="#with--bind">with / bind</a></li>
<li><a href="#e">{e}</a></li>
</ul>
<h2 id="tau"><a class="header" href="#tau"><code>tau</code></a></h2>
<p><code>tau</code> is the type of types.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-neut">define sample(): unit {
  // `tau` used as a term
  let foo = tau in
  Unit
}

// `tau` used as a type
define identity(a: tau, x: a): a {
  x
}
</code></pre>
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<pre><code class="language-neut">tau
</code></pre>
<h3 id="semantics"><a class="header" href="#semantics">Semantics</a></h3>
<p><code>tau</code> is compiled into a pointer to <code>base.#.imm</code>.</p>
<h3 id="type"><a class="header" href="#type">Type</a></h3>
<pre><code class="language-neut">(Γ is a context)
----------------
  Γ ⊢ tau: tau
</code></pre>
<h2 id="local-variables"><a class="header" href="#local-variables">Local Variables</a></h2>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-neut">define sample(): unit {
  // defining/using various local variables
  let x = Unit in
  let foo = x in
  let 'bar = foo in
  let buz' = 'bar in
  let _h-e-l-l-o = buz' in
  let αβγ = _h-e-l-l-o in
  let theSpreadingWideMyNarrowHandsToGatherParadise = αβγ in
  let 冥きより冥き道にぞ入りぬべきはるかに照らせ山の端の月 = Unit in
  let _ = Unit in

  // shadowing (not reassignment)
  let x = Unit in
  let x = tau in
  let x =
    function (x: bool) {
      x // x: bool
    }
  in
  Unit
}
</code></pre>
<h3 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h3>
<p>The name of a local variable must satisfy the following conditions:</p>
<ul>
<li>It doesn't contain any of <code>=() &quot;\n\t:;,&lt;&gt;[]{}/*|</code></li>
<li>It doesn't start with <code>A, B, .., Z</code> (the upper case alphabets)</li>
</ul>
<h3 id="semantics-1"><a class="header" href="#semantics-1">Semantics</a></h3>
<p>If the content of a variable <code>x</code> is an immediate value, <code>x</code> is compiled into the name of a register that stores the immediate. Otherwise, <code>x</code> is compiled into the name of a register that stores a pointer to the content.</p>
<h3 id="type-1"><a class="header" href="#type-1">Type</a></h3>
<pre><code class="language-neut">  Γ ⊢ a: tau
----------------
Γ, x: a ⊢ x: a
</code></pre>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<ul>
<li>The compiler reports unused variables. You can use the name <code>_</code> to suppress those.</li>
<li>Variables in Neut are immutable. You'll need <code>core.cell</code> to achieve mutability.</li>
</ul>
<h2 id="top-level-variables"><a class="header" href="#top-level-variables">Top-Level Variables</a></h2>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-neut">import {
  core.bool {bool},
  B,
}

define sample(): unit {
  // using top-level variables
  let _ = bool // using an imported top-level name
  let _ = core.bool.bool // using the definite description of `core.bool.bool`
  let _ = B.bool // using a prefixed top-level name
  Unit
}
</code></pre>
<h3 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h3>
<p>The name of a top-level variable is a (possibly) dot-separated symbols, where each symbol must satisfy the following conditions:</p>
<ul>
<li>It doesn't contain any of <code>=() &quot;\n\t:;,&lt;&gt;[]{}/*|</code></li>
</ul>
<h3 id="semantics-2"><a class="header" href="#semantics-2">Semantics</a></h3>
<p>A top-level variable <code>f</code> is compiled into the following 3-word tuple:</p>
<pre><code>(base.#.imm, 0, POINTER_TO_FUNCTION(f))
</code></pre>
<p>See the Note below for a more detailed explanation.</p>
<h3 id="type-2"><a class="header" href="#type-2">Type</a></h3>
<pre><code class="language-neut">(Γ is a context)     (c: a is defined at the top-level)
-------------------------------------------------------
                  Γ ⊢ c: a
</code></pre>
<h3 id="note"><a class="header" href="#note">Note</a></h3>
<p>Let's see how top-level variables are compiled. Consider the following top-level functions:</p>
<pre><code class="language-neut">// (source-dir)/sample.nt

// defining a top-level variable `increment`
define increment(x: int): int {
  add-int(x, 1)
}

define get-increment(): (int) -&gt; int {
  increment // using a top-level variable `increment`
}
</code></pre>
<p>This <code>increment</code> and <code>get-increment</code> are compiled into LLVM functions like the below:</p>
<pre><code class="language-llvm">; (build-dir)/path/to/sample.ll

define fastcc ptr @&quot;this.sample.increment&quot;(ptr %_1) {
  %_2 = ptrtoint ptr %_1 to i64
  %_3 = add i64 %_2, 1
  %_4 = inttoptr i64 %_3 to ptr
  ret ptr %_4
}

define fastcc ptr @&quot;this.sample.get-increment&quot;() {
  ; `increment` in `get-increment` is lowered to the following code:

  ; calculate the size of 3-word tuples
  %_1 = getelementptr ptr, ptr null, i32 3
  %_2 = ptrtoint ptr %_1 to i64
  ; allocate memory
  %_3 = call fastcc ptr @malloc(i64 %_2)
  ; store contents
  %_4 = getelementptr [3 x ptr], ptr %_3, i32 0, i32 0
  %_5 = getelementptr [3 x ptr], ptr %_3, i32 0, i32 1
  %_6 = getelementptr [3 x ptr], ptr %_3, i32 0, i32 2
  store ptr @&quot;base.#.imm&quot;, ptr %_4            ; tuple[0] = `base.#.imm`
  store ptr null, ptr %_5                     ; tuple[1] = null
  store ptr @&quot;this.sample.increment&quot;, ptr %_6 ; tuple[2] = (function pointer)
  ; return the pointer to the tuple
  ret ptr %_3
}
</code></pre>
<p>Incidentally, these 3-word tuples are optimized away as long as top-level variables (functions) are called directly with arguments.</p>
<h2 id="let"><a class="header" href="#let"><code>let</code></a></h2>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-neut">define use-let(): unit {
  // 🌟 `let`
  let t = &quot;test&quot; in
  print(t)
}

define use-let(): unit {
  let bar =
    // 🌟 nested `let`
    let foo = some-func() in
    other-func(foo)
  in
  do-something(bar)
}

define use-let(): unit {
  // 🌟 `let` with a type annotation
  let t: &amp;text = &quot;test&quot; in
  print(t)
}

</code></pre>
<p><code>let</code> can be used to destructure an ADT value:</p>
<pre><code class="language-neut">data item {
| Item(int, bool)
}

define use-item(x: item): unit {
  // 🌟 use `let` with a pattern
  let Item(i, b) = x in // ← here
  print-int(i)
}

define use-item-2(x: item): unit {
  // 🌟 use `let` with an of-pattern
  let Item of {i} = x in
  print-int(i)
}
</code></pre>
<h3 id="syntax-3"><a class="header" href="#syntax-3">Syntax</a></h3>
<pre><code class="language-neut">let x = e1 in e2

let x: t = e1 in e2
</code></pre>
<h3 id="semantics-3"><a class="header" href="#semantics-3">Semantics</a></h3>
<p><code>let x = e1 in e2</code> binds the result of <code>e1</code> to the variable <code>x</code>. This <code>x</code> can then be used in <code>e2</code>.</p>
<h3 id="type-3"><a class="header" href="#type-3">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e1: a     Γ, x: a ⊢ e2: b
-----------------------------
   Γ ⊢ let x = e1 in e2: b
</code></pre>
<h3 id="note-1"><a class="header" href="#note-1">Note</a></h3>
<p>(1) <code>let x = e1 in e2</code> isn't exactly the same as <code>{function (x) {e2}}(e1)</code>. The difference lies in the fact that the type of <code>e2</code> can't depend on <code>x</code> in <code>let x = e1 in e2</code>.</p>
<p>(2) When a pattern is passed, <code>let</code> is the following syntax sugar:</p>
<pre><code class="language-neut">let pat = x in
cont

↓

match x {
| pat =&gt;
  cont
}
</code></pre>
<h2 id="integers"><a class="header" href="#integers">Integers</a></h2>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-neut">define foo(): unit {
  let _: int = 100 in
  //           ^^^
  let _: int16 = 100 in
  //             ^^^
  Unit
}

</code></pre>
<h3 id="syntax-4"><a class="header" href="#syntax-4">Syntax</a></h3>
<p><code>3</code>, <code>-16</code>, <code>424242</code>, etc.</p>
<h3 id="semantics-4"><a class="header" href="#semantics-4">Semantics</a></h3>
<p>The same as LLVM integers.</p>
<h3 id="type-4"><a class="header" href="#type-4">Type</a></h3>
<p>The type of an integer is unknown in itself. It must be inferred to be one of the following types:</p>
<ul>
<li><code>int1</code></li>
<li><code>int2</code></li>
<li>...</li>
<li><code>int64</code></li>
</ul>
<h3 id="note-2"><a class="header" href="#note-2">Note</a></h3>
<ul>
<li>The type <code>int</code> is also available. For more, see <a href="./primitives.html#primitive-types">Primitives</a>.</li>
</ul>
<h2 id="floats"><a class="header" href="#floats">Floats</a></h2>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><code class="language-neut">define foo(): unit {
  let _: float = 3.8 in
  //             ^^^
  let _: float32 = 3.8 in
  //             ^^^^^^
  Unit
}

</code></pre>
<h3 id="syntax-5"><a class="header" href="#syntax-5">Syntax</a></h3>
<p><code>3.8</code>, <code>-0.2329</code>, etc.</p>
<h3 id="semantics-5"><a class="header" href="#semantics-5">Semantics</a></h3>
<p>The same as LLVM floats.</p>
<h3 id="type-5"><a class="header" href="#type-5">Type</a></h3>
<p>The type of an integer is unknown in itself. It must be inferred to be one of the following types:</p>
<ul>
<li><code>float16</code></li>
<li><code>float32</code></li>
<li><code>float64</code></li>
</ul>
<h3 id="note-3"><a class="header" href="#note-3">Note</a></h3>
<ul>
<li>The type <code>float</code> is also available. For more, see <a href="./primitives.html#primitive-types">Primitives</a>.</li>
</ul>
<h2 id="texts"><a class="header" href="#texts">Texts</a></h2>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<pre><code class="language-neut">define foo(): unit {
  let _: &amp;text = &quot;test&quot; in
  //             ^^^^^^
  Unit
}

</code></pre>
<h3 id="syntax-6"><a class="header" href="#syntax-6">Syntax</a></h3>
<p><code>&quot;hello&quot;</code>, <code>&quot;Hello, world!\n&quot;</code>, etc.</p>
<h3 id="semantics-6"><a class="header" href="#semantics-6">Semantics</a></h3>
<p>A text literal is compiled into a pointer to a tuple like the following:</p>
<pre><code class="language-text">(0, length-of-string, array-of-characters)
</code></pre>
<p>This tuple is static. More specifically, a global constant like the following is inserted into the resulting IR.</p>
<pre><code class="language-llvm">@&quot;text-hello&quot; = private unnamed_addr constant {i64, i64, [5 x i8]} {i64 0, i64 5, [5 x i8] c&quot;hello&quot;}
</code></pre>
<p>And a text like <code>&quot;hello&quot;: &amp;text</code> is compiled into <code>ptr @&quot;text-hello&quot;</code>.</p>
<h3 id="type-6"><a class="header" href="#type-6">Type</a></h3>
<pre><code class="language-neut">(Γ is a context)  (t is a text literal)
---------------------------------------
         Γ ⊢ t: &amp;text
</code></pre>
<h3 id="note-4"><a class="header" href="#note-4">Note</a></h3>
<ul>
<li>In the current implementation, the set of recognized escape sequences like <code>\n</code> or <code>\t</code> are the same as that of Haskell.</li>
</ul>
<h2 id="x1-a1--xn-an---b"><a class="header" href="#x1-a1--xn-an---b"><code>(x1: a1, ..., xn: an) -&gt; b</code></a></h2>
<p><code>(x1: a1, ..., xn: an) -&gt; b</code> is the type of functions.</p>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<pre><code class="language-neut">// a function that accepts ints and returns bools
(value: int) -&gt; bool

// this is equivalent to `(_: int) -&gt; bool`:
(int) -&gt; bool

// use a type variable
(a: tau, x: a) -&gt; a

// make the first argument implicit
&lt;a: tau&gt;(x: a) -&gt; a

// this is equivalent to `&lt;a: _&gt;(x: a) -&gt; a`
&lt;a&gt;(x: a) -&gt; a
</code></pre>
<h3 id="syntax-7"><a class="header" href="#syntax-7">Syntax</a></h3>
<pre><code class="language-neut">&lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm) -&gt; c
</code></pre>
<p>The following abbreviations are available:</p>
<pre><code class="language-neut">(y1: b1, ..., ym: bm) -&gt; c

// ↓
// &lt;&gt;(y1: b1, ..., ym: bm) -&gt; c


(b1, ..., bm) -&gt; c

// ↓
// (_: b1, ..., _: bm) -&gt; c


&lt;a1, ..., an&gt;(y1: b1, ..., ym: bm) -&gt; c

// ↓
// &lt;a1: _, ..., an: _&gt;(y1: b1, ..., ym: bm) -&gt; c
</code></pre>
<h3 id="semantics-7"><a class="header" href="#semantics-7">Semantics</a></h3>
<p>A function type is compiled into a pointer to <code>base.#.cls</code>. For more, please see <a href="./how-to-execute-types.html">How to Execute Types</a></p>
<h3 id="type-7"><a class="header" href="#type-7">Type</a></h3>
<pre><code class="language-neut">  Γ, x1: a1, ..., xn: an, y1: b1, ..., ym: bm ⊢ c: tau
--------------------------------------------------------
Γ ⊢ &lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm) -&gt; c: tau
</code></pre>
<h2 id="function-x1-a1--xn-an--e-"><a class="header" href="#function-x1-a1--xn-an--e-"><code>function (x1: a1, ..., xn: an) { e }</code></a></h2>
<p><code>function</code> can be used to create a lambda abstraction (an anonymous function).</p>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<pre><code class="language-neut">define use-function(): int {
  let f =
    function (x: int, y: int) {
      let z = add-int(x, y) in
      mul-int(z, z)
    }
  in
  f(10, 20)
}
</code></pre>
<h3 id="syntax-8"><a class="header" href="#syntax-8">Syntax</a></h3>
<pre><code class="language-neut">function (x1: a1, ..., xn: an) {
  e
}
</code></pre>
<h3 id="semantics-8"><a class="header" href="#semantics-8">Semantics</a></h3>
<p>A <code>function</code> is compiled into a three-word closure. For more, please see <a href="./how-to-execute-types.html#advanced-function-types">How to Execute Types</a>.</p>
<h3 id="type-8"><a class="header" href="#type-8">Type</a></h3>
<pre><code class="language-neut">    Γ, x1: a1, ..., xn: an ⊢ e: t
-----------------------------------------
Γ ⊢ function (x1: a1, ..., xn: an) {e}: t

</code></pre>
<h3 id="note-5"><a class="header" href="#note-5">Note</a></h3>
<ul>
<li>Lambda abstractions defined by <code>function</code> are reduced at compile-time when possible. If you would like to avoid this behavior, consider using <code>define</code>.</li>
</ul>
<h2 id="define-fx1-a1--xn-an-c--e-"><a class="header" href="#define-fx1-a1--xn-an-c--e-"><code>define f(x1: a1, ..., xn: an): c { e }</code></a></h2>
<p><code>define</code> (at the term-level) can be used to create a function with possible recursion.</p>
<h3 id="example-9"><a class="header" href="#example-9">Example</a></h3>
<pre><code class="language-neut">define use-define(): int {
  let c = 10 in
  let f =
    // 🌟 term-level `define` with a free variable `c`
    define some-recursive-func(x: int): int {
      if eq-int(x, 0) {
        0
      } else {
        add-int(c, some-recursive-func(sub-int(x, 1)))
      }
    }
  in
  f(100)
}
</code></pre>
<h3 id="syntax-9"><a class="header" href="#syntax-9">Syntax</a></h3>
<pre><code class="language-neut">define name&lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm): c {
  e
}
</code></pre>
<p>The following abbreviations are available:</p>
<pre><code class="language-neut">define name(y1: b1, ..., ym: bm): c {e}

// ↓
// define name&lt;&gt;(y1: b1, ..., ym: bm): c {e}


define name&lt;a1, ..., an&gt;(y1: b1, ..., ym: bm): c {e}

// ↓
// define name&lt;a1: _, ..., an: _&gt;(y1: b1, ..., ym: bm) -&gt; c
</code></pre>
<h3 id="semantics-9"><a class="header" href="#semantics-9">Semantics</a></h3>
<p>A term-level <code>define</code> is lifted to a top-level definition using lambda lifting. For example, consider the following example:</p>
<pre><code class="language-neut">define use-define(): int {
  let c = 10 in
  let f =
    // 🌟 term-level `define` with a free variable `c`
    define some-recursive-func(x: int): int {
      if eq-int(x, 0) {
        0
      } else {
        add-int(c, some-recursive-func(sub-int(x, 1)))
      }
    }
  in
  f(100)
}
</code></pre>
<p>The code above is compiled into something like the below:</p>
<pre><code class="language-neut">// the free variable `c` is now a parameter
define some-recursive-func(c: int, x: int): int {
  if eq-int(x, 0) {
    0
  } else {
    let f =
      function (x: int) {
        some-recursive-func(c, x)
      }
    in
    add-int(c, f(sub-int(x, 1)))
  }
}

define use-define(): int {
  let c = 10 in
  let f =
    function (x: int) {
      some-recursive-func(c, x)
    }
  in
  f(100)
}
</code></pre>
<h3 id="type-9"><a class="header" href="#type-9">Type</a></h3>
<pre><code class="language-neut">Γ, x1: a1, ..., xn: an, f: (x1: a1, ..., xn: an) -&gt; t ⊢ e: t
------------------------------------------------------------
     Γ ⊢ (define f(x1: a1, ..., xn: an):t {e}): t
</code></pre>
<h3 id="note-6"><a class="header" href="#note-6">Note</a></h3>
<ul>
<li>Functions defined by term-level <code>define</code> aren't inlined at compile-time, even if it doesn't contain any recursions.</li>
</ul>
<h2 id="ee1--en"><a class="header" href="#ee1--en"><code>e(e1, ..., en)</code></a></h2>
<p>Given a function <code>e</code> and arguments <code>e1, ..., en</code>, we can write <code>e(e1, ..., en)</code> to write a function application.</p>
<h3 id="example-10"><a class="header" href="#example-10">Example</a></h3>
<pre><code class="language-neut">define use-function(): unit {
  let _ = foo() in
  //      ^^^^^
  let _ = bar(1) in
  //      ^^^^^^
  let _ = buz(&quot;hello&quot;, True) in
  //      ^^^^^^^^^^^^^^^^^^
  Unit
}
</code></pre>
<h3 id="syntax-10"><a class="header" href="#syntax-10">Syntax</a></h3>
<pre><code class="language-neut">e(e1, ..., en)
</code></pre>
<h3 id="semantics-10"><a class="header" href="#semantics-10">Semantics</a></h3>
<p>Given a funciton application <code>e(e1, ..., en)</code> the system does the following:</p>
<ol>
<li>Computes <code>e</code>, <code>e1</code>, ..., <code>en</code> into values <code>v</code>, <code>v1</code>, ..., <code>vn</code></li>
<li>Extracts the content of the closure <code>v</code>, obtaining the label of the closed function and the tuple of the free variables</li>
<li>Deallocates the tuple of the closure <code>v</code></li>
<li>Calls the function label with the tuple and <code>v1, ..., vn</code> as arguments</li>
</ol>
<h3 id="type-10"><a class="header" href="#type-10">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e: &lt;x1: a1, .., xn: an&gt;(y1: b1, .., ym: bm) -&gt; c    Γ ⊢ e1: b1  ..   Γ ⊢ em: bm
---------------------------------------------------------------------------------------
    Γ ⊢ e(e1, .., en): c[x1 := ?M1, .., xn := ?Mn, y1 := e1, .., ym := em]
</code></pre>
<p>The <code>?Mi</code>s in the above rule are metavariables that must be inferred by the compiler.</p>
<h3 id="note-7"><a class="header" href="#note-7">Note</a></h3>
<p>If the function <code>e</code> contains implicit arguments, holes are inserted automatically.</p>
<p>For example, consider the following code:</p>
<pre><code class="language-neut">define id&lt;a&gt;(x: a): a {
  x
}

define use-id(): unit {
  id(Unit)
}
</code></pre>
<p>The <code>id(Unit)</code> in the example above is (conceptually) compiled into the below:</p>
<pre><code class="language-neut">define _id(a: tau, x: a): a {
  x
}

define use-id(): unit {
  _id(_, Unit) // ← a hole `_` is inserted here
}
</code></pre>
<h2 id="e-of-x1--e1--xn--en"><a class="header" href="#e-of-x1--e1--xn--en"><code>e of {x1 = e1, ..., xn = en}</code></a></h2>
<p><code>e of {x1 = e1, ..., xn = en}</code> is an alternative notation of function application.</p>
<h3 id="example-11"><a class="header" href="#example-11">Example</a></h3>
<pre><code class="language-neut">define foo(x: int, y: bool, some-path: &amp;text): unit {
  // whatever
}

define use-foo(): unit {
  // 🌟
  foo of {
    x = 10,
    y = True,
    some-path = &quot;/path/to/file&quot;,
  }
}
</code></pre>
<h3 id="syntax-11"><a class="header" href="#syntax-11">Syntax</a></h3>
<pre><code class="language-neut">e of {x1 = e1, ..., xn = en}
</code></pre>
<h3 id="semantics-11"><a class="header" href="#semantics-11">Semantics</a></h3>
<p>The same as <code>e(e1, ..., en)</code>.</p>
<h3 id="type-11"><a class="header" href="#type-11">Type</a></h3>
<p>The same as <code>e(e1, ..., en)</code>.</p>
<h3 id="note-8"><a class="header" href="#note-8">Note</a></h3>
<p>This notation might be useful when used in combination with ADTs:</p>
<pre><code class="language-neut">data config {
| Config(
    count: int,
    path: &amp;text,
    colorize: bool,
  )
}

constant some-config {
  Config of {
    count = 10,
    colorize = True,
    path = &quot;/path/to/file&quot;, // you can reorder arguments
  }
}
</code></pre>
<p>If the argument is a variable that has the same name as the parameter, you can use a shorthand notation:</p>
<pre><code class="language-neut">define use-foo(): unit {
  let x = 10 in
  let y = True in
  let some-path = &quot;/path/to/file&quot;
  // 🌟
  foo of {x, y, some-path}
}
</code></pre>
<h2 id="exact-e"><a class="header" href="#exact-e"><code>exact e</code></a></h2>
<p>Given a function <code>e</code>, <code>exact e</code> supplies all the implicit variables of <code>e</code> by inserting holes.</p>
<h3 id="example-12"><a class="header" href="#example-12">Example</a></h3>
<pre><code class="language-neut">define id&lt;a&gt;(x: a): a {
  x
}

define use-id() {
                           // 🌟
  let g: (x: int) -&gt; int = exact id in
  Unit
}
</code></pre>
<p>Note that the following won't type-check:</p>
<pre><code class="language-neut">define id&lt;a&gt;(x: a): a {
  x
}

define use-id() {
  let g: (x: int) -&gt; int = id in
  Unit
}
</code></pre>
<p>This is because the type of <code>id</code> is <code>&lt;a&gt;(x: a) -&gt; a</code>, not <code>(x: ?M) -&gt; ?M</code>.</p>
<h3 id="syntax-12"><a class="header" href="#syntax-12">Syntax</a></h3>
<pre><code class="language-neut">exact e
</code></pre>
<h3 id="semantics-12"><a class="header" href="#semantics-12">Semantics</a></h3>
<p>Given a term <code>e</code> of type <code>&lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm) -&gt; c</code>,</p>
<pre><code class="language-neut">exact e
</code></pre>
<p>is translated into the following:</p>
<pre><code class="language-neut">function (y1: b1, ..., ym: bm) {
  e(_, ..., _, y1, ..., ym)
}
</code></pre>
<h3 id="type-12"><a class="header" href="#type-12">Type</a></h3>
<pre><code class="language-neut">       Γ ⊢ e: &lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm) -&gt; c
--------------------------------------------------------------------
Γ ⊢ exact e: ((y1: b1, ..., ym: bm) -&gt; c)[x1 := ?M1, ..., xn := ?Mn]
</code></pre>
<p>Here, <code>?Mi</code>s are metavariables that must be inferred by the type checker.</p>
<h3 id="note-9"><a class="header" href="#note-9">Note</a></h3>
<p>As you can see from its semantics, an <code>exact</code> is just a shorthand of a &quot;hole-application&quot;.</p>
<h2 id="adt-formation"><a class="header" href="#adt-formation">ADT Formation</a></h2>
<p>After defining an ADT using the statement <code>data</code>, you can use the ADT.</p>
<h3 id="example-13"><a class="header" href="#example-13">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

define use-nat-type(): tau {
  // 🌟
  my-nat
}
</code></pre>
<h3 id="syntax-13"><a class="header" href="#syntax-13">Syntax</a></h3>
<p>The same as that of top-level variables.</p>
<h3 id="semantics-13"><a class="header" href="#semantics-13">Semantics</a></h3>
<p>The same as that of top-level variables.</p>
<h3 id="type-13"><a class="header" href="#type-13">Type</a></h3>
<p>If an ADT <code>some-adt</code> is nullary, the type of <code>some-adt</code> is <code>tau</code>.</p>
<p>Otherwise, suppose that an ADT <code>some-adt</code> is defined as follows:</p>
<pre><code class="language-neut">data some-adt(x1: a1, ..., xn: an) {..}
</code></pre>
<p>In this case, the type of <code>some-adt</code> is <code>(x1: a1, ..., xn: an) -&gt; tau</code>.</p>
<h2 id="constructors-adt-introduction"><a class="header" href="#constructors-adt-introduction">Constructors (ADT Introduction)</a></h2>
<p>After defining an ADT using the statement <code>data</code>, you can use the constructors to construct values of the ADT.</p>
<h3 id="example-14"><a class="header" href="#example-14">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

define create-nat(): my-nat {
  // 🌟 (`Succ` and `Zero` are constructors)
  Succ(Succ(Zero))
}
</code></pre>
<h3 id="syntax-14"><a class="header" href="#syntax-14">Syntax</a></h3>
<p>The same as that of top-level variables, except that constructors must be capitalized.</p>
<h3 id="semantics-14"><a class="header" href="#semantics-14">Semantics</a></h3>
<p>The same as that of top-level variables.</p>
<h3 id="type-14"><a class="header" href="#type-14">Type</a></h3>
<p>If a constructor <code>c</code> is nullary, the type of <code>c</code> is the ADT type. For example, consider the following code:</p>
<pre><code class="language-neut">data some-adt {
| c1
}

data other-adt(a: tau) {
| c2
}
</code></pre>
<p>In this case,</p>
<ul>
<li>the type of <code>c1</code> is <code>some-adt</code>, and</li>
<li>the type of <code>c2</code> is <code>other-adt(?M)</code>, where the <code>?M</code> must be inferred by the compiler.</li>
</ul>
<p>If a constructor <code>c</code> isn't nullary, the type of <code>c</code> is the function type that takes specified arguments and turns them into the ADT type. For example, consider the following code:</p>
<pre><code class="language-neut">data some-adt {
| c1(foo: int)
}

data other-adt(a: tau) {
| c2(bar: bool, buz: other-adt(a))
}
</code></pre>
<p>In this case,</p>
<ul>
<li>the type of <code>c1</code> is <code>(foo: int) -&gt; some-adt</code>, and</li>
<li>the type of <code>c2</code> is <code>&lt;a: tau&gt;(bar: bool, buz: other-adt(a)) -&gt; other-adt(a)</code>.</li>
</ul>
<h2 id="match"><a class="header" href="#match"><code>match</code></a></h2>
<p>You can use <code>match</code> to destructure ADT values.</p>
<h3 id="example-15"><a class="header" href="#example-15">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

define foo(n: my-nat): int {
  // 🌟
  match n {
  | Zero =&gt;
    100
  | Succ(m) =&gt;
    foo(m)
  }
}

define bar(n: my-nat): int {
  // 🌟 (You can use nested patterns)
  match n {
  | Zero =&gt;
    100
  | Succ(Succ(m)) =&gt; // ← a nested pattern
    200
  | Succ(m) =&gt;
    foo(m)
  }
}

define eq-nat(n1: my-nat, n2: my-nat): bool {
  // 🌟 (`match` can handle multiple values)
  match n1, n2 {
  | Zero, Zero =&gt;
    True
  | Succ(m1), Succ(m2) =&gt;
    eq-nat(m1, m2)
  | _, _ =&gt;
    False
  }
}


</code></pre>
<h3 id="syntax-15"><a class="header" href="#syntax-15">Syntax</a></h3>
<pre><code class="language-neut">match e1, ..., en {
| pattern-1 =&gt;
  body-1
  ...
| pattern-m =&gt;
  body-m
}
</code></pre>
<h3 id="semantics-15"><a class="header" href="#semantics-15">Semantics</a></h3>
<p>The semantics of <code>match</code> is the same as the semantics of ordinary pattern matching, except that ADT values are <em>consumed</em> after branching.</p>
<p>For example, let's see how <code>my-nat</code> in the following code is used in <code>match</code>:</p>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}
</code></pre>
<p>The internal representation of <code>n: my-nat</code> is something like the below:</p>
<pre><code class="language-neut">Zero:
  (0) // 1-word tuple
Succ:
  (1, pointer-to-m) // 2-word tuple
</code></pre>
<p>When evaluating <code>match</code>, the computer inspects the first element of the &quot;tuple&quot; <code>n</code>.</p>
<pre><code class="language-neut">define foo(n: my-nat): int {
  // 🌟 (inspects the first element of `n` here)
  match n {
  | Zero =&gt;
    100
  | Succ(m) =&gt;
    foo(m)
  }
}
</code></pre>
<p>If the first element is <code>0</code>, which means that we found an ADT value of <code>Zero</code>, the computer <em>frees</em> the outer tuple of <code>(0)</code>, and then evaluates <code>100</code>.</p>
<p>If the first element is <code>1</code>, which means that we found an ADT value of <code>Succ</code>, the computer gets the pointer to the second element of <code>n</code>, binds it to <code>m</code>, <em>frees</em> the outer tuple of <code>(1, pointer-to-m)</code>, and then evaluates <code>foo(m)</code>.</p>
<h3 id="type-15"><a class="header" href="#type-15">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e1: a1
...
Γ ⊢ en: an

Γ, arg_{1,1}: t_{1,1}, ..., arg_{1, k_{1}}: t{1, k_{1}} ⊢ pat-1: a1
Γ, arg_{1,1}: t_{1,1}, ..., arg_{1, k_{1}}: t{1, k_{1}} ⊢ body-1: b

...

Γ, arg_{m,1}: t_{m,1}, ..., arg_{m, k_{m}}: t{m, k_{m}} ⊢ pat-m: an
Γ, arg_{m,1}: t_{m,1}, ..., arg_{m, k_{m}}: t{m, k_{m}} ⊢ body-m: b

(for all i = 1, ..., m, pat-i is a pattern for e1, ..., en)
(the sequence pat-1, ..., pat-m is a exhaustinve matching against e1, ..., en)
------------------------------------------------------------------------------
Γ ⊢ match e1, ..., en {
    | pat-1 =&gt; body-1
    ...
    | pat-m =&gt; body-m
    }: b
</code></pre>
<p>The above might be a bit overwhelming. Please see the following Note for an example.</p>
<h3 id="note-10"><a class="header" href="#note-10">Note</a></h3>
<p>An example of the application of the typing rule of <code>match</code>:</p>
<pre><code class="language-neut">Γ ⊢ n: my-nat

Γ ⊢ Zero: my-nat // pat-1
Γ ⊢ 100: int // body-1

Γ, m: my-nat ⊢ Succ(m): my-nat // pat-2
Γ, m: my-nat ⊢ foo(m): int // body-2

(Zero and Succ(m) are patterns for n)
(the sequence Zero, Succ(m) is a exhaustinve matching against n)
------------------------------------------------------------------------------
Γ ⊢ match n {
    | Zero =&gt; 100
    | Succ(m) =&gt; foo(m)
    }: int
</code></pre>
<h2 id="case"><a class="header" href="#case"><code>case</code></a></h2>
<p>You can use <code>case</code> to inspect noetic ADT values.</p>
<h3 id="example-16"><a class="header" href="#example-16">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

define foo-noetic(n: &amp;my-nat): int {
  case n {
  | Zero =&gt;
    100
  | Succ(m) =&gt;
    // the type of foo-noetic is `(&amp;my-nat) -&gt; int`
    foo-noetic(m)
  }
}
</code></pre>
<h3 id="syntax-16"><a class="header" href="#syntax-16">Syntax</a></h3>
<pre><code class="language-neut">case e1, ..., en {
| pattern-1 =&gt;
  body-1
  ...
| pattern-m =&gt;
  body-m
}
</code></pre>
<h3 id="semantics-16"><a class="header" href="#semantics-16">Semantics</a></h3>
<p>The semantics of <code>case</code> is the same as <code>match</code>, except that <code>case</code> doesn't consume ADT values.</p>
<h3 id="type-16"><a class="header" href="#type-16">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e1: a1
...
Γ ⊢ en: an

Γ, arg_{1,1}: t_{1,1}, ..., arg_{1, k_{1}}: t{1, k_{1}} ⊢ pat-1: a1
Γ, arg_{1,1}: &amp;t_{1,1}, ..., arg_{1, k_{1}}: &amp;t{1, k_{1}} ⊢ body-1: b

...

Γ, arg_{m,1}: t_{m,1}, ..., arg_{m, k_{m}}: t{m, k_{m}} ⊢ pat-m: an
Γ, arg_{m,1}: &amp;t_{m,1}, ..., arg_{m, k_{m}}: &amp;t{m, k_{m}} ⊢ body-m: b

(for all i = 1, ..., m, pat-i is a pattern for e1, ..., en)
(the sequence pat-1, ..., pat-m is a exhaustinve matching against e1, ..., en)
------------------------------------------------------------------------------
Γ ⊢ case e1, ..., en {
    | pat-1 =&gt; body-1
    ...
    | pat-m =&gt; body-m
    }: b
</code></pre>
<h3 id="note-11"><a class="header" href="#note-11">Note</a></h3>
<p>An example of the application of the typing rule of <code>case</code>:</p>
<pre><code class="language-neut">Γ ⊢ n: &amp;my-nat

Γ ⊢ Zero: my-nat // pat-1
Γ ⊢ 100: int // body-1

Γ, m: my-nat ⊢ Succ(m): my-nat // pat-2
Γ, m: &amp;my-nat ⊢ foo-noetic(m): int // body-2

(Zero and Succ(m) are patterns for n)
(the sequence Zero, Succ(m) is a exhaustinve matching against n)
------------------------------------------------------------------------------
Γ ⊢ case n {
    | Zero =&gt; 100
    | Succ(m) =&gt; foo-noetic(m)
    }: int
</code></pre>
<h2 id="a"><a class="header" href="#a"><code>&amp;a</code></a></h2>
<p>Given a type <code>a: tau</code>, the <code>&amp;a</code> is the type of noemata over <code>a</code>.</p>
<h3 id="example-17"><a class="header" href="#example-17">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

                     // 🌟
define foo-noetic(n: &amp;my-nat): int {
  case n {
  | Zero =&gt;
    100
  | Succ(m) =&gt;
    foo-noetic(m)
  }
}
</code></pre>
<h3 id="syntax-17"><a class="header" href="#syntax-17">Syntax</a></h3>
<pre><code class="language-neut">&amp;t
</code></pre>
<h3 id="semantics-17"><a class="header" href="#semantics-17">Semantics</a></h3>
<p>For every type <code>a</code>, <code>&amp;a</code> is compiled into <code>base.#.imm</code>.</p>
<h3 id="type-17"><a class="header" href="#type-17">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ t: tau
-----------
Γ ⊢ &amp;t: tau
</code></pre>
<h3 id="note-12"><a class="header" href="#note-12">Note</a></h3>
<ul>
<li>Values of type <code>&amp;a</code> can be created using <code>on</code>.</li>
<li>Values of type <code>&amp;a</code> are expected to be used in combination with <code>case</code> or <code>*e</code>.</li>
<li>Since <code>&amp;a</code> is compiled into <code>base.#.imm</code>, values of type <code>&amp;a</code> aren't discarded or copied even when used non-linearly.</li>
</ul>
<h2 id="on"><a class="header" href="#on"><code>on</code></a></h2>
<p><code>let x on y = e1 in e2</code> can be used to introduce noetic values in a specific scope.</p>
<h3 id="example-18"><a class="header" href="#example-18">Example</a></h3>
<pre><code class="language-neut">define play-with-let-on(): unit {
  let xs: list(int) = [1, 2, 3] in
  let len on xs =
    // the type of `xs` is `&amp;list(int)` here
    length(xs)
  in
  // the type of `xs` is `list(int)` here
  print-int(len)
}
</code></pre>
<h3 id="syntax-18"><a class="header" href="#syntax-18">Syntax</a></h3>
<pre><code class="language-neut">let y on x1, ..., xn = e1 in
e2
</code></pre>
<h3 id="semantics-18"><a class="header" href="#semantics-18">Semantics</a></h3>
<p><code>on</code> is conceptually the following syntax sugar:</p>
<pre><code class="language-neut">let result on x = e in
cont

// ↓ desugar

let x = unsafe-cast(a, &amp;a, x) in // cast: `a` ~&gt; `&amp;a`
let result = e in                // (use `&amp;a`)
let x = unsafe-cast(&amp;a, a, x) in // uncast: `&amp;a` ~&gt; `a`
cont
</code></pre>
<h3 id="type-18"><a class="header" href="#type-18">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ x1: a1
...
Γ ⊢ xn: an
Γ, x1: &amp;a1, ..., xn: &amp;an ⊢ e1: b // note: the context `Γ` is ordered
Γ, y: b ⊢ e2: c
(the type `b` is actual) // see the below note for the definition of &quot;actual&quot;
---------------------------------------
Γ ⊢ let y on x1, ..., xn = e1 in e2: c
</code></pre>
<h3 id="note-13"><a class="header" href="#note-13">Note</a></h3>
<p>As you can see from the definition of <code>let-on</code>, a noema always has its source value. We'll call it the hyle of a noema.</p>
<p>A noema doesn't make sense if its hyle is discarded. This means, for example, we can break memory safety if <code>let-on</code> can return a noema:</p>
<pre><code class="language-neut">let xs = [1, 2] in
let result on xs = xs in // **CAUTION** the result of let-on is a noema
let _ = xs in    // ← Since the variable `_` isn't used,
                 // the hyle of `result`, namely `xs: list(int)`, is discarded here
match result {   // ... and thus using `result` here is a use-after-free!
| Nil =&gt;
  print(&quot;hey&quot;)
| Cons(y, ys) =&gt;
  print(&quot;yo&quot;)
}
</code></pre>
<p>Thus, we need to restrict the value <code>result</code> so that it can't contain any noemata. For example, types like <code>list(int)</code>, <code>unit</code>, or <code>except(list(int), text)</code> are allowed. types like <code>&amp;text</code>, <code>list(a)</code>, <code>int -&gt; bool</code> are disallowed.</p>
<p>More specifically, the type of <code>result</code> must be &quot;actual&quot;; The type must satisfy all of the following conditions:</p>
<ul>
<li>It doesn't contain any free variables</li>
<li>It doesn't contain any noetic types</li>
<li>It doesn't contain any function types (since a noema can reside in it)</li>
<li>It doesn't contain any &quot;dubious&quot; ADTs</li>
</ul>
<p>Here, a &quot;dubious&quot; ADT is something like the below:</p>
<pre><code class="language-neut">// the type `joker-x` is dubious since it contains a noetic argument
data joker-x {
| HideX(&amp;list(int))
}

// the type `joker-y` is dubious since it contains a functional argument
data joker-y {
| HideY(int -&gt; bool)
}

// the type `joker-z` is dubious since it contains a dubious ADT argument
data joker-z {
| HideZ(joker-y)
}
</code></pre>
<p>Indeed, if we were to allow returning these dubious ADTs, we could exploit them to hide a noema:</p>
<pre><code class="language-neut">let result on xs = HideX(xs) in // the type of `result` is `jokerX` (dubious)
let _ = xs in                   // `xs` is discarded here
match result {
| HideX(xs) =&gt;
  *xs                           // CRASH: use-after-free!
}
</code></pre>
<p>This restriction is checked at compile time by the type system of Neut.</p>
<h2 id="e"><a class="header" href="#e"><code>*e</code></a></h2>
<p>You can use <code>*e</code> to create a non-noetic value from a noetic value.</p>
<h3 id="example-19"><a class="header" href="#example-19">Example</a></h3>
<pre><code class="language-neut">define clone-list&lt;a&gt;(xs: &amp;list(a)): list(a) {
  case xs {
  | Nil =&gt;
    Nil
  | Cons(y, ys) =&gt;
    Cons(*y, clone-list(ys))
  }
}
</code></pre>
<h3 id="syntax-19"><a class="header" href="#syntax-19">Syntax</a></h3>
<pre><code class="language-neut">*e
</code></pre>
<h3 id="semantics-19"><a class="header" href="#semantics-19">Semantics</a></h3>
<p>Given a noema <code>e: &amp;t</code>, <code>*e</code> is a clone of the hyle of the noema.</p>
<p>This clone is created by copying the hyle along the type <code>t</code>.</p>
<p>The original hyle is kept intact.</p>
<h3 id="type-19"><a class="header" href="#type-19">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e: &amp;a
----------
Γ ⊢ *e: a
</code></pre>
<h2 id="flow"><a class="header" href="#flow"><code>flow</code></a></h2>
<p>A <code>flow</code> in Neut is the type of control flow (much like promises in other languages).</p>
<h3 id="example-20"><a class="header" href="#example-20">Example</a></h3>
<pre><code class="language-neut">flow(int) // the type of control flow that returns int

flow((int) -&gt; bool) // the type of control flow that returns (int) -&gt; bool
</code></pre>
<h3 id="syntax-20"><a class="header" href="#syntax-20">Syntax</a></h3>
<pre><code class="language-neut">flow(t)
</code></pre>
<h3 id="semantics-20"><a class="header" href="#semantics-20">Semantics</a></h3>
<p>For any type <code>t</code>, the type <code>flow(t)</code> is compiled into a pointer to a closed function that discards and copies the values of the type in the following manner:</p>
<ul>
<li>Discard <code>e: flow(t)</code>: Waits the flow <code>e</code> to finish and discard the result along the type <code>t</code>, and then returns 0</li>
<li>Copy <code>e: flow(t)</code>: Waits the flow <code>e</code> to finish and copy the result along the type <code>t</code>, creates an already-finished control flow, and returns it as a clone.</li>
</ul>
<p>The type <code>t</code> is inside the internal representation of <code>e</code>. Because of that, for any <code>t</code>, <code>flow(t)</code> is compiled to the same closed function. For more, see the following Note.</p>
<h3 id="type-20"><a class="header" href="#type-20">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ t: tau
----------------
Γ ⊢ flow(t): tau
</code></pre>
<h3 id="note-14"><a class="header" href="#note-14">Note</a></h3>
<p>(1) The internal representation of <code>e: flow(t)</code> is a &quot;3-word + 1-byte&quot; tuple like the below:</p>
<pre><code class="language-neut">   (thread-id, t, result-value-or-none, finished)
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^
//  3-word                              1-byte
</code></pre>
<p>When a flow is created,</p>
<ul>
<li>the value of <code>result-value-or-none</code> is initialized to 0, and</li>
<li>the value of <code>finished</code> is also initialized to 0.</li>
</ul>
<p>When a flow is completed,</p>
<ul>
<li>the value <code>result-value-or-none</code> is updated to the result of the flow and</li>
<li>the value <code>finished</code> is updated to 1.</li>
</ul>
<p>(2) As you can see from the semantics, you must use control flows linearly to perform parallel computation.</p>
<p>(3) A flow in Neut is a thin layer over pthread.</p>
<h2 id="detach"><a class="header" href="#detach"><code>detach</code></a></h2>
<p>You can use <code>detach</code> to create a new control flow.</p>
<h3 id="example-21"><a class="header" href="#example-21">Example</a></h3>
<pre><code class="language-neut">define foo(): flow(int) {
  detach {
    print(&quot;fA&quot;);
    1
  }
}

define bar(): flow(int) {
  let f =
    detach {
      print(&quot;fA&quot;);
      1
    }
  in
  whatever();
  f
}
</code></pre>
<h3 id="syntax-21"><a class="header" href="#syntax-21">Syntax</a></h3>
<pre><code class="language-neut">detach {
  e
}
</code></pre>
<h3 id="semantics-21"><a class="header" href="#semantics-21">Semantics</a></h3>
<p><code>detach { e }</code> creates a new control flow and starts computation of <code>e</code> in that flow.</p>
<h3 id="type-21"><a class="header" href="#type-21">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e: a
-------------------------
Γ ⊢ detach { e }: flow(a)
</code></pre>
<h3 id="note-15"><a class="header" href="#note-15">Note</a></h3>
<ul>
<li><code>detach</code> internally uses pthread.</li>
</ul>
<h2 id="attach"><a class="header" href="#attach"><code>attach</code></a></h2>
<p>You can use <code>detach</code> to wait for a control flow and get its result.</p>
<h3 id="example-22"><a class="header" href="#example-22">Example</a></h3>
<pre><code class="language-neut">define foo(f: flow(int)): int {
  attach { f }
}

define bar(f: flow((int) -&gt; bool)): bool {
  let k = attach { f } in
  k(100)
}
</code></pre>
<h3 id="syntax-22"><a class="header" href="#syntax-22">Syntax</a></h3>
<pre><code class="language-neut">attach { e }
</code></pre>
<h3 id="semantics-22"><a class="header" href="#semantics-22">Semantics</a></h3>
<p><code>attach</code> waits given computational flow to finish and gets its resulting value.</p>
<p>It also <code>free</code>s the 3-word + 1-byte tuple that represents a control flow after getting the result.</p>
<h3 id="type-22"><a class="header" href="#type-22">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e: flow(a)
-------------------
Γ ⊢ attach { e }: a
</code></pre>
<h3 id="note-16"><a class="header" href="#note-16">Note</a></h3>
<ul>
<li><code>attach</code> internally uses pthread.</li>
</ul>
<h2 id="new-channel"><a class="header" href="#new-channel"><code>new-channel</code></a></h2>
<p>You can create channels using <code>new-channel</code> and send/receive values using those channels.</p>
<h3 id="example-23"><a class="header" href="#example-23">Example</a></h3>
<pre><code class="language-neut">define sample(): unit {
  let ch0 = new-channel(int) in
  let ch1 = new-channel(int) in
  // use channels after turning them into noemata
  let result on ch0, ch1 =
    let f =
      detach {
        let message0 = receive(_, ch0) in // receive value from ch0
        send(int, ch1, add-int(message0, 1)); // send value to ch1
        message0
      }
    in
    let g =
      detach {
        let message1 = receive(_, ch1) in // receive value from ch1
        add-int(message1, 1)
      }
    in
    send(int, ch0, 0); // send value to ch0
    let v1 = attach { f } in
    let v2 = attach { g } in
    print(&quot;hey&quot;)
  in
  // ... cont ...
}
</code></pre>
<h3 id="syntax-23"><a class="header" href="#syntax-23">Syntax</a></h3>
<pre><code class="language-neut">new-channel(e)
</code></pre>
<h3 id="semantics-23"><a class="header" href="#semantics-23">Semantics</a></h3>
<p><code>new-channel</code> creates a new channel that can be used to send/receive values between flows.</p>
<p>The internal representation of <code>channel(a)</code> is something like the below:</p>
<pre><code class="language-neut">(queue, thread-mutex, thread-cond, a)
</code></pre>
<p>The <code>queue</code> is the place where inter-channel values are enqueued/dequeued. More specifically,</p>
<ul>
<li>the function <code>send: &lt;a&gt;(ch: &amp;channel, x: a) -&gt; unit</code> enqueues values to there, and</li>
<li>the function <code>receive: &lt;a&gt;(ch: &amp;channel) -&gt; a</code> dequeues values from there.</li>
</ul>
<p>The <code>thread-mutex</code> is initialized by <code>pthread_mutex_init(3)</code>. This field is used to update the queue in a thread-safe way.</p>
<p>The <code>thread-cond</code> is initialized by <code>pthread_cond_init(3)</code>. This field is used to update the queue in a thread-safe way.</p>
<h3 id="type-23"><a class="header" href="#type-23">Type</a></h3>
<pre><code>
------------------------------------
Γ ⊢ new-channel: &lt;a&gt;() -&gt; channel(a)
</code></pre>
<h3 id="note-17"><a class="header" href="#note-17">Note</a></h3>
<ul>
<li>Channels are intended to be used with flows.</li>
<li>You'll use a channel after turning them into a noema (as in the example above).</li>
<li>You can use <code>send: &lt;a&gt;(ch: &amp;channel, x: a) -&gt; unit</code> to enqueue a value to the channel.</li>
<li>You can use <code>receive: &lt;a&gt;(ch: &amp;channel) -&gt; a</code> to dequeue a value from the channel. <code>receive</code> blocks if there is no value to read.</li>
<li><code>new-channel: &lt;a&gt;() -&gt; channel(a)</code> is a normal function defined in the core library.</li>
</ul>
<p>Also, <code>channel(a)</code> can be used as a basis for mutable variables. The idea is to create a channel that is always of length 1. The type <code>cell(a)</code> is there to represent such a channel:</p>
<p>Below is an example of using the type <code>cell</code>:</p>
<pre><code class="language-neut">define sample(): int {
  let xs: list(int) = [] in

  // create a new cell using `new-cell`
  let xs-cell = new-cell(list(int), xs) in

  // create a noema of a cell
  let result on xs-cell =
    // mutate the cell using `mutate` (add an element)
    mutate(xs-cell, function (xs) {
      Cons(1, xs)
    });

    // peek the content of a cell using `borrow`
    borrow(xs-cell, function (xs) {
      let len = length(xs) in
      print-int(len) // =&gt; 1
    })

    // mutate again
    mutate(xs-cell, function (xs) {
      Cons(2, xs)
    });

    // get the length of the list in the cell, again
    borrow(xs-cell, function (xs) {
      let len = length(xs) in
      print-int(len) // =&gt; 2
    })

    ...
  in
  ...
}
</code></pre>
<p>Here, the type of related wrapper functions are:</p>
<pre><code class="language-neut">// create a new channel
new-cell&lt;a&gt;(x: a): cell(a)

// mutate the content of a cell by `f`
mutate&lt;a&gt;(ch: &amp;cell(a), f: (a) -&gt; a): unit

// borrow the content of a cell and do something
borrow&lt;a&gt;(ch: &amp;cell(a), f: (&amp;a) -&gt; unit): unit

// clone the content of a cell
clone&lt;a&gt;(ch: &amp;cell(a)): a
</code></pre>
<p>The definition of, for example, <code>mutate</code> is essentially something like the below:</p>
<pre><code class="language-neut">define mutate&lt;a&gt;(ch: &amp;cell(a), f: (a) -&gt; a): unit {
  let ch = Magic.cast(&amp;cell(a), &amp;channel(a), ch) in
  let v = receive(ch) in
  send(ch, f(v))
}
</code></pre>
<h2 id="magic"><a class="header" href="#magic"><code>magic</code></a></h2>
<p>You can use <code>magic</code> to perform weird stuff. Using <code>magic</code> is an unsafe operation.</p>
<h3 id="example-24"><a class="header" href="#example-24">Example</a></h3>
<pre><code class="language-neut">// empty type
data descriptor {}

// add an element to the empty type
constant stdin: descriptor {
  magic cast(int, descriptor, 0) // 🌟 cast
}

define malloc-then-free(): unit {
  // allocate memory region
  let size: int = 10 in
  let ptr: int = magic external malloc(size) in // 🌟 external

  // store a value
  let value: int = 123 in
  magic store(int, value, ptr); // 🌟 store

  // load and print a value
  let value = magic load(int, ptr) in // 🌟 load
  print-int(value); // =&gt; 123

  // free the pointer and return
  magic external free(ptr); // 🌟 external
  Unit
}

</code></pre>
<h3 id="syntax-24"><a class="header" href="#syntax-24">Syntax</a></h3>
<pre><code class="language-neut">magic cast(from-type, to-type, value)

magic store(lowtype, stored-value, address)

magic load(lowtype, address)

magic external func-name(e1, ..., en)

magic external func-name(e1, ..., en)(vararg-1: lowtype-1, ..., vararg-n: lowtype-n)
</code></pre>
<p>A &quot;lowtype&quot; is one of the following:</p>
<ul>
<li><code>int1</code>, <code>int2</code>, ..., <code>int64</code></li>
<li><code>float16</code>, <code>float32</code>, <code>float64</code></li>
<li><code>pointer</code></li>
</ul>
<p>You can also use <code>int</code> and <code>float</code> as a lowtype. These are platform-dependent lowtypes. If the target architecture is 64-bit, <code>int</code> is interpreted as <code>int64</code>.</p>
<h3 id="semantics-24"><a class="header" href="#semantics-24">Semantics</a></h3>
<p><code>magic cast (a, b, e)</code> casts the term <code>e</code> from the type <code>a</code> to <code>b</code>. <code>cast</code> does nothing at runtime.</p>
<p><code>magic store(lowtype, value, address)</code> stores a value <code>value</code> to <code>address</code>. This is the same as <code>store</code> <a href="https://llvm.org/docs/LangRef.html#store-instruction">in LLVM</a>.</p>
<p><code>magic load(lowtype, address)</code> loads a value from <code>address</code>. This is the same as <code>load</code> <a href="https://llvm.org/docs/LangRef.html#load-instruction">in LLVM</a>.</p>
<p><code>magic external func(e1, ..., en)</code> can be used to call foreign functions (or FFI). See <a href="./statements.html#foreign">foreign in Statements</a> for more information.</p>
<p><code>magic external func(e1, ..., en)(e{n+1}: lowtype1, ..., e{n+m}: lowtypem)</code> can also be used to call variadic foreign functions like printf in C. A use of such varidic <code>external</code> can be found in the core library <a href="https://github.com/vekatze/neut-core/blob/6ef2fed68a6b0b063e15350e788c82ea9371f6bb/source/text/io.nt#L43">here</a>.</p>
<h3 id="type-24"><a class="header" href="#type-24">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ t1: tau
Γ ⊢ t2: tau
Γ ⊢ e: t1
-----------------------------
Γ ⊢ magic cast(t1, t2, e): t2


Γ ⊢ stored-value: t1
Γ ⊢ address: t2
Γ ⊢ t3: tau
(value-type is a low-type)
------------------------------------------------------
Γ ⊢ magic store(value-type, stored-value, address): t3


Γ ⊢ address: t1
Γ ⊢ t2: tau
(value-type is a low-type)
------------------------------------------------------
Γ ⊢ magic load(value-type, address): t2


Γ ⊢ e1: t1
...
Γ ⊢ en: tn
Γ ⊢ t: tau
(func-name is a foreign function)
--------------------------------------------------
Γ ⊢ magic external func-name(e1, ..., en): t


Γ ⊢ e1: t1
...
Γ ⊢ en: tn
Γ ⊢ e{n+1}: t{n+1}
...
Γ ⊢ e{n+m}: t{n+m}
(lt-1 is a low-type)
...
(lt-m is a low-type)
Γ ⊢ t: tau
(func-name is a foreign function)
-----------------------------------------------------------------------------
Γ ⊢ magic external func-name(e1, ..., en)(e{n+1}: lt-1, ..., e{n+m}: lt-m): t
</code></pre>
<h3 id="note-18"><a class="header" href="#note-18">Note</a></h3>
<p>Except for <code>cast</code>, the result type of <code>magic</code> is unspecified. You may have to supply annotations.</p>
<h2 id="introspect"><a class="header" href="#introspect"><code>introspect</code></a></h2>
<p>You can use <code>introspect key {..}</code> to introspect the compiler's configuration.</p>
<h3 id="example-25"><a class="header" href="#example-25">Example</a></h3>
<pre><code class="language-neut">define arch-dependent-constant(): int {
  introspect target-arch {
  | arm64 =&gt;
    1
  | amd64 =&gt;
    2
  }
}

define os-dependent-constant(): int {
  introspect target-os {
  | linux =&gt;
    1
  | default =&gt;
    // `2` is returned if target-os != linux
    2
  }
}
</code></pre>
<h3 id="syntax-25"><a class="header" href="#syntax-25">Syntax</a></h3>
<pre><code class="language-neut">introspect key {
| value-1 =&gt;
  e1
  ...
| value-n =&gt;
  en
}
</code></pre>
<p>You can use the following configuration <code>key</code>s and configuration <code>value</code>s:</p>
<div class="table-wrapper"><table><thead><tr><th>Configuration Key</th><th>Configuration Value</th></tr></thead><tbody>
<tr><td><code>target-arch</code></td><td><code>amd64</code> or <code>arm64</code></td></tr>
<tr><td><code>target-os</code></td><td><code>linux</code> or <code>darwin</code></td></tr>
<tr><td><code>build-mode</code></td><td><code>develop</code> or <code>release</code></td></tr>
</tbody></table>
</div>
<p>You can also use <code>default</code> as a configuration value to represent a fallback case.</p>
<h3 id="semantics-25"><a class="header" href="#semantics-25">Semantics</a></h3>
<p>Firstly, <code>introspect key {v1 =&gt; e1 | ... | vn =&gt; en}</code> looks up the configuration value <code>v</code> of the compiler by <code>key</code>. Then it reads the configuration values <code>v1</code>, ..., <code>vn</code> in this order to find <code>vk</code> that is equal to the <code>v</code>. If such a <code>vk</code> is found, <code>introspect</code> executes the corresponding clause <code>ek</code>. If no such <code>vk</code> is found, <code>introspect</code> will report a compilation error.</p>
<p>The configuration value <code>default</code> is equal to any configuration values.</p>
<h3 id="type-25"><a class="header" href="#type-25">Type</a></h3>
<pre><code class="language-neut">(key is a configuration key)

(v1 is a configuration value)
Γ ⊢ e1: a

...

(vn is a configuration value)
Γ ⊢ en: a
------------------------------------------
Γ ⊢ introspect key {
    | v1 =&gt; e1
      ...
    | vn =&gt; en
    }: a
</code></pre>
<h3 id="note-19"><a class="header" href="#note-19">Note</a></h3>
<ul>
<li>The branching of an <code>introspect</code> is resolved at compile-time.</li>
</ul>
<h2 id="admit"><a class="header" href="#admit"><code>admit</code></a></h2>
<p>You can use <code>admit</code> to suppress the type checker and sketch the structure of your program.</p>
<h3 id="example-26"><a class="header" href="#example-26">Example</a></h3>
<pre><code class="language-neut">define my-complex-function(): unit {
  admit
}
</code></pre>
<h3 id="syntax-26"><a class="header" href="#syntax-26">Syntax</a></h3>
<pre><code class="language-neut">admit
</code></pre>
<h3 id="sematics"><a class="header" href="#sematics">Sematics</a></h3>
<p>Evaluating <code>admit</code> will exit the program, displaying a message like the following:</p>
<pre><code class="language-text">admit: /path/to/file.nt:1:2
</code></pre>
<p>When <code>admit</code> exits a program, the exit code is 1.</p>
<h3 id="type-26"><a class="header" href="#type-26">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ t: tau
------------
Γ ⊢ admit: t
</code></pre>
<h3 id="note-20"><a class="header" href="#note-20">Note</a></h3>
<ul>
<li><code>admit</code> is the <code>undefined</code> in Haskell.</li>
<li><code>admit</code> is intended to be used ephemerally during development.</li>
</ul>
<h2 id="assert"><a class="header" href="#assert"><code>assert</code></a></h2>
<p>You can use <code>assert</code> to ensure that a condition is satisfied at run-time.</p>
<h3 id="example-27"><a class="header" href="#example-27">Example</a></h3>
<pre><code class="language-neut">define fact(n: int): int {
  assert &quot;the input must be non-negative&quot; {
    ge-int(n, 0)
  };
  if eq-int(n, 0) {
    1
  } else {
    mul-int(n, fact(sub-int(n, 1)))
  }
}
</code></pre>
<h3 id="syntax-27"><a class="header" href="#syntax-27">Syntax</a></h3>
<pre><code class="language-neut">assert &quot;any-string&quot; {
  e
}
</code></pre>
<h3 id="semantics-26"><a class="header" href="#semantics-26">Semantics</a></h3>
<p>If the <a href="./commands.html#--mode">build mode</a> is <code>release</code>, <code>assert</code> does nothing.</p>
<p>Otherwise, <code>assert &quot;description&quot; { condition }</code> evaluates <code>condition</code> and checks if it is <code>True</code>. If it is <code>True</code>, the <code>assert</code> simply evaluates to <code>Unit</code>. Otherwise, it reports that the assertion <code>&quot;description&quot;</code> failed and exits the execution of the program with the exit code <code>1</code>.</p>
<h3 id="type-27"><a class="header" href="#type-27">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ condition: bool
--------------------------------------------
Γ ⊢ assert &quot;description&quot; { condition }: unit
</code></pre>
<h2 id="_"><a class="header" href="#_"><code>_</code></a></h2>
<p><code>_</code> is a hole that must be inferred by the type checker.</p>
<h3 id="example-28"><a class="header" href="#example-28">Example</a></h3>
<pre><code class="language-neut">define id(a: tau, x: a): a {
  x
}

define use-hole(): unit {
  id(_, Unit) // ← using a hole (inferred to be `unit`)
}
</code></pre>
<h3 id="syntax-28"><a class="header" href="#syntax-28">Syntax</a></h3>
<pre><code class="language-neut">_
</code></pre>
<h3 id="semantics-27"><a class="header" href="#semantics-27">Semantics</a></h3>
<p><code>_</code> is a hole that must be inferred by the type checker. If the type checker resolves a hole into a term <code>e</code>, this hole behaves the same as <code>e</code>. If the type checker can't resolve a hole, the type checker reports a compilation error.</p>
<h3 id="type-28"><a class="header" href="#type-28">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e[tmp := e1]: a
-------------------
Γ ⊢ e[tmp := _]: a
</code></pre>
<h3 id="note-21"><a class="header" href="#note-21">Note</a></h3>
<p>Please do not confuse a hole with the <code>_</code> in <code>let _ = e1 in e2</code>.</p>
<h2 id="use-e-x1--xn-in-cont"><a class="header" href="#use-e-x1--xn-in-cont"><code>use e {x1, ..., xn} in cont</code></a></h2>
<p>You can use <code>use e {x1, ..., xn} in cont</code> as a shorthand to destructure an ADT that has only one constructor.</p>
<h3 id="example-29"><a class="header" href="#example-29">Example</a></h3>
<pre><code class="language-neut">data config {
| Config(
    path: &amp;text,
    count: int,
  )
}

define use-config(c: config): unit {
  use c {count} in
  print-int(count)
}

// cf.
define use-config-2(c: config): unit {
  let Config of {count} = c in
  print-int(count)
}
</code></pre>
<h3 id="syntax-29"><a class="header" href="#syntax-29">Syntax</a></h3>
<pre><code class="language-neut">use e {x1, ..., xn} in
cont
</code></pre>
<h3 id="semantics-28"><a class="header" href="#semantics-28">Semantics</a></h3>
<p><code>use</code> is the following syntax sugar:</p>
<pre><code class="language-neut">use e {x1, ..., xn} in
cont

↓

let K of {x1, ..., xn} = e in
cont
</code></pre>
<p>Here, the <code>K</code> is the only constructor of the type of <code>e</code>. If the type of e contains more than one constructor, <code>use</code> results in a compilation error.</p>
<h3 id="type-29"><a class="header" href="#type-29">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="ex"><a class="header" href="#ex"><code>e::x</code></a></h2>
<p>You can use <code>e::x</code> to extract a value from an ADT value.</p>
<h3 id="example-30"><a class="header" href="#example-30">Example</a></h3>
<pre><code class="language-neut">data config {
| Config(
    path: &amp;text,
    count: int,
  )
}

define use-config(c: config): unit {
  print-int(c::count)
}
</code></pre>
<h3 id="syntax-30"><a class="header" href="#syntax-30">Syntax</a></h3>
<pre><code class="language-neut">e::x
</code></pre>
<h3 id="semantics-29"><a class="header" href="#semantics-29">Semantics</a></h3>
<p><code>::</code> is the following syntax sugar:</p>
<pre><code class="language-neut">e::x

↓

use e {x} in
x
</code></pre>
<h3 id="type-30"><a class="header" href="#type-30">Type</a></h3>
<p>Derived from the desugared form.</p>
<h3 id="note-22"><a class="header" href="#note-22">Note</a></h3>
<p>One possible use of <code>::</code> is to select a function from a record of functions:</p>
<pre><code class="language-neut">// dict.nt ---------------------------------

...

// declare a record of functions (like signatures in OCaml)
data trope(k) {
| Trope(
    insert: &lt;v&gt;(k, v, dict(k, v)) -&gt; dict(k, v),
    lookup: &lt;v&gt;(&amp;k, &amp;dict(k, v)) -&gt; ?&amp;v,
    delete: &lt;v&gt;(k, dict(k, v)) -&gt; dict(k, v),
  )
}

// foo.nt ----------------------------------

import {
  Dict,
  ...
}

// create a record of functions
constant intdict: Dict.trope(int) {
  // ... whatever ...
}

// ... and use a function of the record
define make-big-dict(): dict(int, int) {
  loop(700000, Dict.empty(), function (acc, _) {
    let key = random(1000000) in
    let val = random(1000000) in
    intdict::insert(key, val, acc) // 🌟
  })
}
</code></pre>
<p>You can find a working example of such a use case <a href="https://github.com/vekatze/neut-core/blob/main/source/bench/random-dict.nt">in the core library</a>.</p>
<h2 id="if"><a class="header" href="#if"><code>if</code></a></h2>
<p>You can use <code>if</code> as in other languages.</p>
<h3 id="example-31"><a class="header" href="#example-31">Example</a></h3>
<pre><code class="language-neut">define foo(b1: bool): unit {
  if b1 {
    print(&quot;hey&quot;)
  } else {
    print(&quot;yo&quot;)
  }
}

define bar(b1: bool, b2: bool): unit {
  let tmp =
    if b1 {
      &quot;hey&quot;
    } else-if b2 {
      &quot;yo&quot;
    } else {
      &quot;pohe&quot;
    }
  in
  print(tmp)
}
</code></pre>
<h3 id="syntax-31"><a class="header" href="#syntax-31">Syntax</a></h3>
<pre><code class="language-neut">if b1 { e1 } else-if b2 { e2 }  ... else-if b_{n-1} { e_{n-1} } else { en }
</code></pre>
<h3 id="semantics-30"><a class="header" href="#semantics-30">Semantics</a></h3>
<p><code>if</code> is the following syntax sugar:</p>
<pre><code class="language-neut">if b1 { e1 } else-if b2 { e2 }  ... else-if b_{n-1} { e_{n-1} } else { en }

↓

match b1 {
| True =&gt; e1
| False =&gt;
  match b2 {
  | True =&gt; e2
  | False =&gt;
    ...
    match b_{n-1} {
    | True =&gt; e_{n-1}
    | False =&gt; en
    }
  }
}
</code></pre>
<h3 id="type-31"><a class="header" href="#type-31">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="when-cond--e-"><a class="header" href="#when-cond--e-"><code>when cond { e }</code></a></h2>
<p>You can use <code>when cond { e }</code> to perform <code>e</code> only when <code>cond</code> is true.</p>
<h3 id="example-32"><a class="header" href="#example-32">Example</a></h3>
<pre><code class="language-neut">define foo(b1: bool): unit {
  when b1 {
    print(&quot;hey&quot;)
  }
}

</code></pre>
<h3 id="syntax-32"><a class="header" href="#syntax-32">Syntax</a></h3>
<pre><code class="language-neut">when cond {
  e
}
</code></pre>
<h3 id="semantics-31"><a class="header" href="#semantics-31">Semantics</a></h3>
<p><code>when</code> is the following syntax sugar:</p>
<pre><code class="language-neut">when cond {
  e
}

↓

if cond {
  e
} else {
  Unit
}
</code></pre>
<h3 id="type-32"><a class="header" href="#type-32">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="e1-e2"><a class="header" href="#e1-e2"><code>e1; e2</code></a></h2>
<p>You can use <code>e1; e2</code> to perform sequential operations.</p>
<h3 id="example-33"><a class="header" href="#example-33">Example</a></h3>
<pre><code class="language-neut">define foo(): unit {
  print(&quot;hello&quot;);
  print(&quot;, &quot;);
  print(&quot;world!&quot;);
  print(&quot;\n&quot;)
}
</code></pre>
<h3 id="syntax-33"><a class="header" href="#syntax-33">Syntax</a></h3>
<pre><code class="language-neut">e1;
e2
</code></pre>
<h3 id="semantics-32"><a class="header" href="#semantics-32">Semantics</a></h3>
<p><code>e1; e2</code> is the following syntax sugar:</p>
<pre><code class="language-neut">let _: unit = e1 in
e2
</code></pre>
<h3 id="type-33"><a class="header" href="#type-33">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="try-x--e1-in-e2"><a class="header" href="#try-x--e1-in-e2"><code>try x = e1 in e2</code></a></h2>
<p><code>try</code> is a shorthand for <code>match</code> + <code>except</code>.</p>
<h3 id="example-34"><a class="header" href="#example-34">Example</a></h3>
<pre><code class="language-neut">define get-value-or-fail(): except(error, int) {
  // .. whatever ..
}

define foo(): unit {
  try x1 = get-value-or-fail() in
  try x2 = get-value-or-fail() in
  print-int(add-int(x1, x2))
}
</code></pre>
<h3 id="syntax-34"><a class="header" href="#syntax-34">Syntax</a></h3>
<pre><code class="language-neut">try x = e1 in
e2
</code></pre>
<h3 id="semantics-33"><a class="header" href="#semantics-33">Semantics</a></h3>
<p><code>try x = e1 in e2</code> is a shorthand of the below:</p>
<pre><code class="language-neut">match e1 {
| Fail(err) =&gt;
  Fail(err)
| Pass(x) =&gt;
  e2
}
</code></pre>
<h3 id="type-34"><a class="header" href="#type-34">Type</a></h3>
<p>Derived from the desugared form.</p>
<h3 id="note-23"><a class="header" href="#note-23">Note</a></h3>
<p>The definition of <code>except</code> is as follows:</p>
<pre><code class="language-neut">data except(a, b) {
| Fail(a)
| Pass(b)
}
</code></pre>
<h2 id="tie-x--e1-in-e2"><a class="header" href="#tie-x--e1-in-e2"><code>tie x = e1 in e2</code></a></h2>
<p>You can use <code>tie</code> as a &quot;noetic&quot; <code>let</code>.</p>
<h3 id="example-35"><a class="header" href="#example-35">Example</a></h3>
<pre><code class="language-neut">data config {
| Config(
    foo: int,
    bar: bool,
  )
}

define use-noetic-config(c: &amp;config): int {
  tie Config of {foo} = c in
  *foo
}
</code></pre>
<h3 id="syntax-35"><a class="header" href="#syntax-35">Syntax</a></h3>
<pre><code class="language-neut">tie x = e1 in
e2
</code></pre>
<h3 id="semantics-34"><a class="header" href="#semantics-34">Semantics</a></h3>
<p><code>tie x = e1 in e2</code> is a shorthand of the below:</p>
<pre><code class="language-neut">case e1 {
| x =&gt;
  e2
}
</code></pre>
<h3 id="type-35"><a class="header" href="#type-35">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="t"><a class="header" href="#t"><code>?t</code></a></h2>
<p>You can use <code>?t</code> to represent an optional type.</p>
<h3 id="example-36"><a class="header" href="#example-36">Example</a></h3>
<pre><code class="language-neut">define foo(x: int): ?int {
  if eq-int(x, 0) {
    Pass(100)
  } else {
    Fail(Unit)
  }
}
</code></pre>
<h3 id="syntax-36"><a class="header" href="#syntax-36">Syntax</a></h3>
<pre><code class="language-neut">?t
</code></pre>
<h3 id="semantics-35"><a class="header" href="#semantics-35">Semantics</a></h3>
<p><code>?t</code> is the following syntax sugar:</p>
<pre><code class="language-neut">?t

↓

except(unit, t)
</code></pre>
<h3 id="type-36"><a class="header" href="#type-36">Type</a></h3>
<p>Derived from the syntax sugar.</p>
<h2 id="e1--en"><a class="header" href="#e1--en"><code>[e1, ..., en]</code></a></h2>
<p>You can use <code>[e1, ..., en]</code> to construct a list.</p>
<h3 id="example-37"><a class="header" href="#example-37">Example</a></h3>
<pre><code class="language-neut">define make-int-list(): list(int) {
  [1, 2, 3, 4, 5]
}
</code></pre>
<h3 id="syntax-37"><a class="header" href="#syntax-37">Syntax</a></h3>
<pre><code class="language-neut">[e1, ..., en] // n &gt;= 0
</code></pre>
<h3 id="semantics-36"><a class="header" href="#semantics-36">Semantics</a></h3>
<p><code>[e1, ..., en]</code> is the following syntax sugar:</p>
<pre><code class="language-neut">[e1, ..., en]

↓

Cons(e1, Cons(..., Cons(en, Nil)...))
</code></pre>
<h3 id="type-37"><a class="header" href="#type-37">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="with--bind"><a class="header" href="#with--bind"><code>with</code> / <code>bind</code></a></h2>
<p>You can use <code>with</code> / <code>bind</code> as &quot;do-notations&quot; in other languages.</p>
<h3 id="example-38"><a class="header" href="#example-38">Example</a></h3>
<pre><code class="language-neut">// define a monadic bind
define except-bind&lt;e, a, b&gt;(x: except(e, a), k: (a) -&gt; except(e, b)): except(e, b) {
  match x {
  | Fail(err) =&gt;
    Fail(err)
  | Pass(value) =&gt;
    k(value)
  }
}

define test(): except(&amp;text, int) {
  // ... and supply it to `with`
  with except-bind {
    bind _: bool = Fail(&quot;hello&quot;) in
    bind _: bool = Fail(&quot;hello&quot;) in
    bind _ = Pass(True) in
    bind _: bool =
      bind _ = Pass(True) in
      Fail(&quot;hello&quot;)
    in
    bind _: bool = Fail(&quot;hello&quot;) in
    bind _: tau = Pass(int) in
    Pass(10)
  }
}
</code></pre>
<h3 id="syntax-38"><a class="header" href="#syntax-38">Syntax</a></h3>
<pre><code class="language-neut">with f {
  e
}

bind x = e1 in
e2

bind x: t = e1 in
e2
</code></pre>
<h3 id="semantics-37"><a class="header" href="#semantics-37">Semantics</a></h3>
<p><code>with</code> / <code>bind</code> is the syntax sugar defined by the following five translation rules:</p>
<pre><code class="language-neut">// (1) -----------------------------------------------------

with f {
  bind x = e1 in
  e2
}

↓

f(
  with f {e1},
  function (x) {
    with f {e2}
  }
)

// (2) -----------------------------------------------------

with f {
  LET x = e1 in // LET must be one of `let`, `try`, or `tie`
  e2
}

↓

LET x = with f {e1} in
with f {e2}


// (3) -----------------------------------------------------

with f {
  e1;
  e2
}

↓

with f {e1};
with f {e2}

// (4) -----------------------------------------------------

with f {
  use e {x1 ..., xn} in
  cont
}

↓

use e {x1, ..., xn} in
with f {cont}

// (5) -----------------------------------------------------

with f {e}

↓

e
</code></pre>
<p>The rule <code>(5)</code> is used only when all the other rules are unavailable.</p>
<h3 id="type-38"><a class="header" href="#type-38">Type</a></h3>
<p>Derived from the desugared form.</p>
<h3 id="note-24"><a class="header" href="#note-24">Note</a></h3>
<ul>
<li><code>with</code>/<code>bind</code> is the ordinary do-notation except that:
<ul>
<li>it must have an explicit monadic binder, and</li>
<li>it doesn't have monadic return.</li>
</ul>
</li>
</ul>
<h2 id="e-1"><a class="header" href="#e-1"><code>{e}</code></a></h2>
<p><code>{e}</code> can be used as parentheses in other languages.</p>
<pre><code class="language-neut">              // 🌟
define foo(f: {(int) -&gt; (bool)} -&gt; bool): bool {
  let g =
    function (x: int) {
      True
    }
  in
  f(g)
}


// cf.
define bar(f: (int) -&gt; (bool) -&gt; bool): bool {
  f(10)(True)
}
</code></pre>
<h3 id="syntax-39"><a class="header" href="#syntax-39">Syntax</a></h3>
<pre><code class="language-neut">{e}
</code></pre>
<h3 id="semantics-38"><a class="header" href="#semantics-38">Semantics</a></h3>
<p>The semantics of <code>{e}</code> is the same as <code>e</code>.</p>
<h3 id="type-39"><a class="header" href="#type-39">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e: a
----------
Γ ⊢ {e}: a
</code></pre>

            <footer id="footer-paginator">
              <a rel="prev" href="statements.html" class="nav previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                ← Previous Page
              </a>

              <div id="footer-spacer"></div>

              <a rel="next" href="primitives.html" class="nav next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                Next Page →
              </a>
            </footer>
          </article>
          <div id="footer-wrapper">
            <footer id="footer-nav">
              <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-external-world.html"><strong aria-hidden="true">3.1.</strong> Hello External World</a></li><li class="chapter-item expanded "><a href="programming-in-neut.html"><strong aria-hidden="true">3.2.</strong> Programming in Neut</a></li><li class="chapter-item expanded "><a href="static-memory-management.html"><strong aria-hidden="true">3.3.</strong> Static Memory Management</a></li></ol></li><li class="chapter-item expanded "><a href="language-reference.html"><strong aria-hidden="true">4.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">4.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">4.3.</strong> Statements</a></li><li class="chapter-item expanded "><a href="terms.html" class="active"><strong aria-hidden="true">4.4.</strong> Terms</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">4.5.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basis.html"><strong aria-hidden="true">4.6.</strong> Basis</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-next.html"><strong aria-hidden="true">5.</strong> What is Next?</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="manual-installation.html"><strong aria-hidden="true">6.</strong> Manual Installation</a></li><li class="chapter-item expanded "><a href="development-environment.html"><strong aria-hidden="true">7.</strong> Development Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lovely-lsp-showcase.html"><strong aria-hidden="true">7.1.</strong> Lovely LSP Showcase</a></li><li class="chapter-item expanded "><a href="rapid-prototyping.html"><strong aria-hidden="true">7.2.</strong> Rapid Prototyping</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">7.3.</strong> Editor Setup</a></li></ol></li><li class="chapter-item expanded "><a href="how-to-execute-types.html"><strong aria-hidden="true">8.</strong> How to Execute Types</a></li><li class="chapter-item expanded "><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
            </footer>
          </div>
        </main>
      </div>


      <script src="highlight.js"></script>
      <script src="book.js"></script>
    </div>
  </body>
</html>
