define length-embodied(xs: list(int)): int {
  match xs {
  - Nil =>
    0
  - Cons(_, ys) =>
    add-int(1, length-embodied(ys))
  }
}

define my-length(xs: &list(int)): int {
  length-embodied(!xs)
}

define sum-of-list(xs: &list(int)): int {
  case xs {
  - Nil =>
    0
  - Cons(y, ys) =>
    add-int(!y, sum-of-list(ys))
  }
}

define main(): int {
  let xs = Cons(3, Cons(1, Cons(20, Nil)))
  let some-value on xs = my-length(xs)
  let sum-value on xs = add-int(sum-of-list(xs), some-value)
  let _ = xs
  let _ = sum-value
  0
}
