import {
- core.sum
- core.bool
}

variant nat {
- Zero
- Succ(nat)
}

define interpret(n: nat): int {
  match n {
  - Zero =>
    0
  - Succ(m) =>
    add-int(1, interpret(m))
  }
}

define view(a: tau, b: tau, x: sum(a, b)): int {
  match x {
  - Left(_) =>
    1
  - Right(_) =>
    2
  }
}

define computation-with-error(x: int): sum(nat, int) {
  if eq-int(x, 0) {
    Left(Succ(Zero))
  } else {
    Right(interpret(Succ(Succ(Zero))))
  }
}

define let-sum(x: int): sum(nat, int) {
  let+ foo = computation-with-error(x)
  let+ bar = computation-with-error(add-int(foo, 1))
  Right(bar)
}

define main(): int {
  let _ =
    match let-sum(10) {
    - Left(e) =>
      interpret(e)
    - Right(v) =>
      let x = view(int, i32, Left(10))
      let _ = view(int, i32, Right(10))
      let _ = x
      let _ = x
      add-int(v, 1)
    }
  0
}
