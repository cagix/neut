data heap(a) {
- Leaf
- Node(heap(a), a, heap(a))
}

data order {
- LT
- EQ
- GT
}

define insert[a](cmp: (a, a) -> order, x: a, t: heap(a)): heap(a) {
  let Tuple(smaller, bigger) = split(cmp, x, t)
  Node(smaller, x, bigger)
}

define split[a](cmp: (a, a) -> order, pivot: a, t: heap(a)): tuple(heap(a), heap(a)) {
  match t {
  - Leaf =>
    Tuple(Leaf, Leaf)
  - Node(left, v, right) =>
    match cmp(v, pivot) {
    - LT =>
      // go right
      match right {
      - Leaf =>
        Tuple(Node(left, v, Leaf), Leaf)
      - Node(right-left, w, right-right) =>
        match cmp(w, pivot) {
        - LT =>
          // go right
          let Tuple(right-right-small, right-right-big) = split(cmp, pivot, right-right)
          Tuple(Node(Node(left, v, right-right-small), w, right-right-small), right-right-big)
        - _ =>
          // go left
          let Tuple(right-left-small, right-left-big) = split(cmp, pivot, right-left)
          Tuple(Node(left, v, right-left-small), Node(right-left-big, w, right-right))
        }
      }
    - _ =>
      // go left
      match left {
      - Leaf =>
        Tuple(Leaf, Node(Leaf, v, right))
      - Node(left-left, w, left-right) =>
        match cmp(w, pivot) {
        - LT =>
          // go right
          let Tuple(left-right-small, left-right-big) = split(cmp, pivot, left-right)
          Tuple(Node(left-left, w, left-right-small), Node(left-right-big, v, right))
        - _ =>
          // go left
          let Tuple(left-left-small, left-left-big) = split(cmp, pivot, left-left)
          Tuple(left-left-small, Node(left-left-big, w, Node(left-right, v, right)))
        }
      }
    }
  }
}

define find-min[a](t: &heap(a)): ?a {
  case t {
  - Leaf =>
    None
  - Node(Leaf, x, _) =>
    Some(*x)
  - Node(left, _, _) =>
    find-min(left)
  }
}

define delete-min[a](t: heap(a)): ?heap(a) {
  match t {
  - Leaf =>
    None
  - Node(Leaf, _, right) =>
    Some(right)
  - Node(Node(Leaf, _, t12), y, t2) =>
    Some(Node(t12, y, t2))
  - Node(Node(t11, x, t12), y, t2) =>
    let? t11 = delete-min(t11)
    Some(Node(t11, x, Node(t12, y, t2)))
  }
}

define compare-int-list(xs: list(int), ys: list(int)): order {
  let x on xs = sum(xs)
  let y on ys = sum(ys)
  let _ = xs
  let _ = ys
  if lt-int(x, y) {
    LT
  } else-if gt-int(x, y) {
    GT
  } else {
    EQ
  }
}

define sum(xs: &list(int)): int {
  case xs {
  - [] =>
    0
  - y :: ys =>
    add-int(*y, sum(ys))
  }
}

define main(): unit {
  let h: heap(list(int)) = Leaf
  let h = insert(compare-int-list, [1, 2], h)
  let h = insert(compare-int-list, [10], h)
  let h = insert(compare-int-list, [5], h)
  // v1 = 3
  let v1 on h = {
    match find-min(h) {
    - Some(xs) =>
      let v on xs = sum(xs) // xs = [1, 2]
      let _ = xs
      v // v = 3
    - None =>
      4
    }
  }
  let mh = delete-min(h)
  let result =
    match mh {
    - None =>
      3
    - Some(h) =>
      let h = insert(compare-int-list, [4, 8], h)
      let h = insert(compare-int-list, [1, 1], h)
      // v2 = 2
      let v2 on h =
        match find-min(h) {
        - Some(xs) =>
          let v on xs = sum(xs) // xs = [1, 1]
          let _ = xs
          v // v = 2
        - None =>
          4
        }

      let _ = h
      // v1 + v2 = 3 + 2 = 5
      add-int(v1, v2)
    }
  print-int(result)
  print("\n")
}
