// random access list via numerical representation
// (complete binary tree + dense representation)

data tree(a) {
- Leaf(a)
- Node(int, tree(a), tree(a))
}

data digit(a) {
- DigitZero
- DigitOne(tree(a))
}

data R-list(a) {
- New(list(digit(a)))
}

define size(a: tau, t: &tree(a)): int {
  case t {
  - Leaf(_) =>
    1
  - Node(w, _, _) =>
    *w
  }
}

define join(a: tau, t1: tree(a), t2: tree(a)): tree(a) {
  let s1 on t1 = size(_, t1) in
  let s2 on t2 = size(_, t2) in
  Node(add-int(s1, s2), t1, t2)
}

define cons-tree(a: tau, t: tree(a), ts: R-list(a)): R-list(a) {
  match ts {
  - New([]) =>
    New([DigitOne(t)])
  - New(DigitZero :: rest) =>
    New(DigitOne(t) :: rest)
  - New(DigitOne(t0) :: rest) =>
    let New(ts-new) = cons-tree(a, join(_, t, t0), New(rest)) in
    New(DigitZero :: ts-new)
  }
}

define cons(a: tau, x: a, ts: R-list(a)): R-list(a) {
  cons-tree(a, Leaf(x), ts)
}

define uncons-tree(a: tau, ts: R-list(a)): option(tuple(tree(a), R-list(a))) {
  let New(xs) = ts in
  match xs {
  - [] =>
    None
  - DigitOne(y) :: [] =>
    Some(Tuple(y, New([])))
  - DigitOne(y) :: rest =>
    Some(Tuple(y, New(DigitZero :: rest)))
  - DigitZero :: rest =>
    match uncons-tree(_, New(rest)) {
    - None =>
      None
    - Some(Tuple(new-tree, New(new-ts))) =>
      match new-tree {
      - Leaf(_) =>
        None
      - Node(_, t1, t2) =>
        Some(Tuple(t1, New(DigitOne(t2) :: new-ts)))
      }
    }
  }
}

define lookup-tree(a: tau, i: int, t: &tree(a)): option(a) {
  case t {
  - Leaf(v) =>
    if eq-int(i, 0) {
      Some(*v)
    } else {
      None
    }
  - Node(w, t1, t2) =>
    let w-div-2 = div-int(*w, 2) in
    if lt-int(i, w-div-2) {
      lookup-tree(a, i, t1)
    } else {
      lookup-tree(a, sub-int(i, w-div-2), t2)
    }
  }
}

define lookup-list(a: tau, i: int, xs: &list(digit(a))): option(a) {
  case xs {
  - [] =>
    None
  - DigitZero :: rest =>
    lookup-list(_, i, rest)
  - DigitOne(t) :: rest =>
    let s = size(_, t) in
    if lt-int(i, s) {
      lookup-tree(_, i, t)
    } else {
      lookup-list(_, sub-int(i, s), rest)
    }
  }
}

define lookup(a: tau, i: int, xs: &R-list(a)): option(a) {
  link New(xs) = xs in
  lookup-list(_, i, xs)
}

define update-tree(a: tau, i: int, x: a, t: tree(a)): tree(a) {
  match t {
  - Leaf(v) =>
    if eq-int(i, 0) {
      Leaf(x)
    } else {
      Leaf(v)
    }
  - Node(w, t1, t2) =>
    let w-div-2 = div-int(w, 2) in
    if lt-int(i, w-div-2) {
      Node(w, update-tree(_, i, x, t1), t2)
    } else {
      Node(w, t1, update-tree(_, sub-int(i, w-div-2), x, t2))
    }
  }
}

define update(a: tau, i: int, x: a, xs: R-list(a)): R-list(a) {
  match xs {
  - New([]) =>
    New([])
  - New(DigitZero :: ts) =>
    let New(new-xs) = update(_, i, x, New(ts)) in
    New(DigitZero :: new-xs)
  - New(DigitOne(t) :: ts) =>
    let s on t = size(_, t) in
    if lt-int(i, s) {
      New(DigitOne(update-tree(_, i, x, t)) :: ts)
    } else {
      let New(new-xs) = update(_, sub-int(i, s), x, New(ts)) in
      New(DigitOne(t) :: new-xs)
    }
  }
}

define find-and-get(i: int, xs: &R-list(int)): int {
  match lookup(_, i, xs) {
  - None =>
    0
  - Some(v) =>
    v
  }
}

define main(): unit {
  let xs = New([]): R-list(int) in
  let xs = cons(_, 3, xs) in
  let xs = cons(_, 2, xs) in
  let xs = cons(_, 4, xs) in
  let xs = cons(_, 1, xs) in
  let v1 on xs = find-and-get(0, xs) in // 1
  let v2 on xs = find-and-get(1, xs) in // 4
  let _ on xs = find-and-get(2, xs) in // 2
  let v4 on xs = find-and-get(3, xs) in // 3
  let xs = update(_, 2, 10, xs) in
  let v3-modified on xs = find-and-get(2, xs) in // 10
  let _ = xs in
  print-int(add-int(v1, add-int(v2, add-int(v3-modified, v4)))); // 1 + 4 + 10 + 3 = 18
  print("\n")
}
