// random access list via numerical representation
// (complete binary tree + dense representation)

data tree(a) {
- Leaf(a)
- Node(int, tree(a), tree(a))
}

data digit(a) {
- DigitZero
- DigitOne(tree(a))
}

data R-list(a) {
- New(list(digit(a)))
}

define size[a](t: &tree(a)): int {
  case t {
  - Leaf(_) =>
    1
  - Node(w, _, _) =>
    *w
  }
}

define join[a](t1: tree(a), t2: tree(a)): tree(a) {
  let s1 on t1 = size(t1)
  let s2 on t2 = size(t2)
  Node(add-int(s1, s2), t1, t2)
}

define cons-tree[a](t: tree(a), ts: R-list(a)): R-list(a) {
  match ts {
  - New([]) =>
    New([DigitOne(t)])
  - New(DigitZero :: rest) =>
    New(DigitOne(t) :: rest)
  - New(DigitOne(t0) :: rest) =>
    let New(ts-new) = cons-tree(join(t, t0), New(rest))
    New(DigitZero :: ts-new)
  }
}

define cons[a](x: a, ts: R-list(a)): R-list(a) {
  cons-tree(Leaf(x), ts)
}

define uncons-tree[a](ts: R-list(a)): option(tuple(tree(a), R-list(a))) {
  let New(xs) = ts
  match xs {
  - [] =>
    None
  - DigitOne(y) :: [] =>
    Some(Tuple(y, New([])))
  - DigitOne(y) :: rest =>
    Some(Tuple(y, New(DigitZero :: rest)))
  - DigitZero :: rest =>
    match uncons-tree(New(rest)) {
    - None =>
      None
    - Some(Tuple(new-tree, New(new-ts))) =>
      match new-tree {
      - Leaf(_) =>
        None
      - Node(_, t1, t2) =>
        Some(Tuple(t1, New(DigitOne(t2) :: new-ts)))
      }
    }
  }
}

define lookup-tree[a](i: int, t: &tree(a)): option(a) {
  case t {
  - Leaf(v) =>
    if eq-int(i, 0) {
      Some(*v)
    } else {
      None
    }
  - Node(w, t1, t2) =>
    let w-div-2 = div-int(*w, 2)
    if lt-int(i, w-div-2) {
      lookup-tree(i, t1)
    } else {
      lookup-tree(sub-int(i, w-div-2), t2)
    }
  }
}

define lookup-list[a](i: int, xs: &list(digit(a))): option(a) {
  case xs {
  - [] =>
    None
  - DigitZero :: rest =>
    lookup-list(i, rest)
  - DigitOne(t) :: rest =>
    let s = size(t)
    if lt-int(i, s) {
      lookup-tree(i, t)
    } else {
      lookup-list(sub-int(i, s), rest)
    }
  }
}

define lookup[a](i: int, xs: &R-list(a)): option(a) {
  link New(xs) = xs
  lookup-list(i, xs)
}

define update-tree[a](i: int, x: a, t: tree(a)): tree(a) {
  match t {
  - Leaf(v) =>
    if eq-int(i, 0) {
      Leaf(x)
    } else {
      Leaf(v)
    }
  - Node(w, t1, t2) =>
    let w-div-2 = div-int(w, 2)
    if lt-int(i, w-div-2) {
      Node(w, update-tree(i, x, t1), t2)
    } else {
      Node(w, t1, update-tree(sub-int(i, w-div-2), x, t2))
    }
  }
}

define update[a](i: int, x: a, xs: R-list(a)): R-list(a) {
  match xs {
  - New([]) =>
    New([])
  - New(DigitZero :: ts) =>
    let New(new-xs) = update(i, x, New(ts))
    New(DigitZero :: new-xs)
  - New(DigitOne(t) :: ts) =>
    let s on t = size(t)
    if lt-int(i, s) {
      New(DigitOne(update-tree(i, x, t)) :: ts)
    } else {
      let New(new-xs) = update(sub-int(i, s), x, New(ts))
      New(DigitOne(t) :: new-xs)
    }
  }
}

define find-and-get(i: int, xs: &R-list(int)): int {
  match lookup(i, xs) {
  - None =>
    0
  - Some(v) =>
    v
  }
}

define main(): unit {
  let xs = New([]): R-list(int)
  let xs = cons(3, xs)
  let xs = cons(2, xs)
  let xs = cons(4, xs)
  let xs = cons(1, xs)
  let v1 on xs = find-and-get(0, xs) // 1
  let v2 on xs = find-and-get(1, xs) // 4
  let _ on xs = find-and-get(2, xs) // 2
  let v4 on xs = find-and-get(3, xs) // 3
  let xs = update(2, 10, xs)
  let v3-modified on xs = find-and-get(2, xs) // 10
  let _ = xs
  print-int(add-int(v1, add-int(v2, add-int(v3-modified, v4)))) // 1 + 4 + 10 + 3 = 18
  print("\n")
}
