import {
- core.bool
- core.option
- core.sum
}

use {
- core.bool
- core.option
- this.finite-map::finite-map
}

enum order() {
- lt()
- eq()
- gt()
}

// for some non-trivial resource value
enum list(a) {
- nil()
- cons(a, list(a))
}

enum finite-map(a, b) {
- leaf()
- node(finite-map(a, b), a, b, finite-map(a, b))
}

struct finite-map-signature(a, b) {
- empty: finite-map(a, b)
- insert: (a, b, finite-map(a, b)) -> finite-map(a, b)
- lookup: (a, &finite-map(a, b)) -> ?b
}

define make-finite-map<a, b>(compare: (a, a) -> order()): finite-map-signature(a, b) {
  new finite-map-signature {
  - finite-map-signature.empty <=
    leaf()
  - finite-map-signature.insert <=
    define insert(key: a, value: b, haystack: finite-map(a, b)): finite-map(a, b) {
      match haystack {
      - leaf() =>
        node(leaf(), key, value, leaf())
      - node(left, k, v, right) =>
        match compare(key, k) {
        - order.lt() =>
          node(insert(key, value, left), k, v, right)
        - order.eq() =>
          node(left, k, value, right)
        - order.gt() =>
          node(left, k, v, insert(key, value, right))
        }
      }
    }
  - finite-map-signature.lookup <=
    define lookup(key: a, haystack: &finite-map(a, b)): ?b {
      case haystack {
      - leaf() =>
        none()
      - node(left, k, v, right) =>
        match compare(key, *k) {
        - order.lt() =>
          lookup(key, left)
        - order.eq() =>
          some(*v)
        - order.gt() =>
          lookup(key, right)
        }
      }
    }
  }
}

define compare-int(x: i64, y: i64): order() {
  if lt-i64(x, y) {
    order.lt()
  } else-if gt-i64(x, y) {
    order.gt()
  } else {
    order.eq()
  }
}

define main(): i64 {
  let intmap = make-finite-map(compare-int)
  match intmap {
  - finite-map-signature.new(empty, insert, lookup) =>
    let mymap = insert(1, [tau], empty)
    let mymap = insert(2, [tau, tau], mymap)
    let mymap = insert(2, [tau, tau], mymap)
    let mymap = insert(2, [i64], mymap)
    let mymap = insert(3, [() -> i64], mymap)
    let aoeu = mymap
    let hoge = mymap
    let result on mymap = {
      match lookup(2, mymap) {
      - core.sum::sum.left(v) =>
        1
      - core.sum::sum.right(xs) =>
        match xs {
        - list.nil() =>
          10
        - list.cons(a, b) =>
          20
        }
      }
    }
    result
  }
}
