import {
- core.text
}

data order {
- LT
- EQ
- GT
}

data finite-map(a, b) {
- Leaf
- Node(finite-map(a, b), a, b, finite-map(a, b))
}

data finite-map-signature(a, b) {
- Finite-Map(
    empty: finite-map(a, b),
    insert: (a, b, finite-map(a, b)) -> finite-map(a, b),
    lookup: (a, &finite-map(a, b)) -> ?b
  )
}

define make-finite-map(a: tau, b: tau, compare: (a, a) -> order): finite-map-signature(a, b) {
  Finite-Map of {
  - empty =>
    Leaf
  - insert =>
    mu insert(key: a, value: b, haystack: finite-map(a, b)): finite-map(a, b) {
      match haystack {
      - Leaf =>
        Node(Leaf, key, value, Leaf)
      - Node(left, k, v, right) =>
        match compare(key, k) {
        - LT =>
          Node(insert(key, value, left), k, v, right)
        - EQ =>
          Node(left, k, value, right)
        - GT =>
          Node(left, k, v, insert(key, value, right))
        }
      }
    }
  - lookup =>
    mu lookup(key: a, haystack: &finite-map(a, b)): ?b {
      case haystack {
      - Leaf =>
        None
      - Node(left, k, v, right) =>
        match compare(key, *k) {
        - LT =>
          lookup(key, left)
        - EQ =>
          Some(*v)
        - GT =>
          lookup(key, right)
        }
      }
    }
  }
}

define compare-int(x: int, y: int): order {
  if lt-int(x, y) {
    LT
  } else-if gt-int(x, y) {
    GT
  } else {
    EQ
  }
}

define main(): unit {
  let Finite-Map of { empty, insert, lookup } = make-finite-map(_, _, compare-int) in
  let mymap = insert(1, [tau], empty) in
  let mymap = insert(2, [tau, tau], mymap) in
  let mymap = insert(2, [tau, tau], mymap) in
  let mymap = insert(2, [int], mymap) in
  let mymap = insert(3, [() -> int], mymap) in
  let _ = mymap in
  let _ = mymap in
  let result on mymap =
    match lookup(2, mymap) {
    - None =>
      1
    - Some(xs) =>
      match xs {
      - [] =>
        10
      - _ :: _ =>
        20
      }
    }
  in
  let _ = mymap in
  print-int(result);
  print("\n")
}
