import {
- core.bool
- core.option
}

use {
- core.bool
- core.option
- this.finite-map::finite-map
}

variant order() {
- LT()
- EQ()
- GT()
}

// for some non-trivial resource value
variant list(a) {
- Nil()
- Cons(a, list(a))
}

variant finite-map(a, b) {
- Leaf()
- Node(finite-map(a, b), a, b, finite-map(a, b))
}

struct finite-map-signature(a, b) {
- empty: finite-map(a, b)
- insert: (a, b, finite-map(a, b)) -> finite-map(a, b)
- lookup: (a, &finite-map(a, b)) -> ?b
}

define make-finite-map<a, b>(compare: (a, a) -> order()): finite-map-signature(a, b) {
  new finite-map-signature {
  - finite-map-signature.empty <=
    Leaf()
  - finite-map-signature.insert <=
    define insert(key: a, value: b, haystack: finite-map(a, b)): finite-map(a, b) {
      match haystack {
      - Leaf() =>
        Node(Leaf(), key, value, Leaf())
      - Node(left, k, v, right) =>
        match compare(key, k) {
        - order.LT() =>
          Node(insert(key, value, left), k, v, right)
        - order.EQ() =>
          Node(left, k, value, right)
        - order.GT() =>
          Node(left, k, v, insert(key, value, right))
        }
      }
    }
  - finite-map-signature.lookup <=
    define lookup(key: a, haystack: &finite-map(a, b)): ?b {
      case haystack {
      - Leaf() =>
        option.None()
      - Node(left, k, v, right) =>
        match compare(key, !k) {
        - order.LT() =>
          lookup(key, left)
        - order.EQ() =>
          option.Some(!v)
        - order.GT() =>
          lookup(key, right)
        }
      }
    }
  }
}

define compare-int(x: i64, y: i64): order() {
  if lt-i64(x, y) {
    order.LT()
  } else-if gt-i64(x, y) {
    order.GT()
  } else {
    order.EQ()
  }
}

define main(): i64 {
  let finite-map-signature.New(empty, insert, lookup) = make-finite-map(compare-int)
  let mymap = insert(1, [tau], empty)
  let mymap = insert(2, [tau, tau], mymap)
  let mymap = insert(2, [tau, tau], mymap)
  let mymap = insert(2, [i64], mymap)
  let mymap = insert(3, [() -> i64], mymap)
  let aoeu = mymap
  let hoge = mymap
  let result on mymap = {
    match lookup(2, mymap) {
    - option.None() =>
      1
    - option.Some(xs) =>
      match xs {
      - [] =>
        10
      - _ :: _ =>
        20
      }
    }
  }
  result
}
