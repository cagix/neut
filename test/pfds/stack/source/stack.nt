import {
- core.bool
- core.option
}

use {
- core.bool
- core.option
}

variant stack(a) {
- Nil()
- Cons(a, stack(a))
}

define empty<a>(): stack(a) {
  stack.Nil()
}

define is-empty<a>(xs: &stack(a)): bool() {
  case xs {
  - stack.Nil() =>
    bool.True()
  - stack.Cons(y, rest) =>
    bool.False()
  }
}

define head<a>(xs: &stack(a)): option(&a) {
  case xs {
  - stack.Nil() =>
    option.None()
  - stack.Cons(a, rest) =>
    option.Some(a)
  }
}

define tail<a>(xs: &stack(a)): option(&stack(a)) {
  case xs {
  - stack.Nil() =>
    option.None()
  - stack.Cons(a, rest) =>
    option.Some(rest)
  }
}

define update<a>(xs: stack(a), index: i64, value: a): stack(a) {
  match xs {
  - stack.Nil() =>
    stack.Nil()
  - stack.Cons(y, ys) =>
    if eq-i64(index, 0) {
      stack.Cons(value, ys)
    } else {
      stack.Cons(y, update(ys, sub-i64(index, 1), value))
    }
  }
}

define suffixes<a>(xs: stack(a)): stack(stack(a)) {
  match xs {
  - stack.Nil() =>
    stack.Nil()
  - stack.Cons(y, ys) =>
    stack.Cons(xs, suffixes(ys))
  }
}

define suffixes-noetic<a>(xs: &stack(a)): stack(&stack(a)) {
  case xs {
  - stack.Nil() =>
    stack.Nil()
  - stack.Cons(y, ys) =>
    stack.Cons(xs, suffixes-noetic(ys))
  }
}

define main(): i64 {
  let xs = empty()
  let ys = stack.Cons(10: i64, xs)
  let zs = stack.Cons(30, stack.Cons(20, ys))
  let zs = update(zs, 1, 20000)
  let ws = suffixes(zs)
  let calc on zs, xs = {
    let b = is-empty(zs)
    let b2 = is-empty(xs)
    let h = head(zs)
    let zs-suffixes = suffixes-noetic(zs)
    let h2 = head(xs)
    let t = tail(zs)
    let t2 = tail(zs)
    if b {
      1
    } else {
      2
    }
  }
  calc
}
