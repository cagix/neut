import {
- core.bool
- core.option
- core.list => L
- core.text => T
}

variant stack(a) {
- Nil
- Cons(a, stack(a))
}

define empty[a](): stack(a) {
  Nil
}

define is-empty[a](xs: &stack(a)): bool {
  case xs {
  - Nil =>
    True
  - Cons(_, _) =>
    False
  }
}

define head[a](xs: &stack(a)): option(&a) {
  case xs {
  - Nil =>
    None
  - Cons(a, _) =>
    Some(a)
  }
}

define tail[a](xs: &stack(a)): option(&stack(a)) {
  case xs {
  - Nil =>
    None
  - Cons(_, rest) =>
    Some(rest)
  }
}

define update[a](xs: stack(a), index: int, value: a): stack(a) {
  match xs {
  - Nil =>
    Nil
  - Cons(y, ys) =>
    if eq-int(index, 0) {
      Cons(value, ys)
    } else {
      Cons(y, update(ys, sub-int(index, 1), value))
    }
  }
}

define suffixes[a](xs: stack(a)): stack(stack(a)) {
  match xs {
  - Nil =>
    Nil
  - Cons(_, ys) =>
    Cons(xs, suffixes(ys))
  }
}

define suffixes-noetic[a](xs: &stack(a)): stack(&stack(a)) {
  case xs {
  - Nil =>
    Nil
  - Cons(_, ys) =>
    Cons(xs, suffixes-noetic(ys))
  }
}

define main(): int {
  let xs = empty()
  let ys = Cons(10: int, xs)
  let zs = Cons(30, Cons(20, ys))
  let zs = update(zs, 1, 20000)
  let _ = suffixes(zs)
  let calc on zs, xs = {
    let b = is-empty(zs)
    let _ = is-empty(xs)
    let _ = head(zs)
    let _ = suffixes-noetic(zs)
    let _ = head(xs)
    let _ = tail(zs)
    let _ = tail(zs)
    if b {
      1
    } else {
      2
    }
  }
  let _ = zs
  let _ = xs
  let _: int = calc
  0
}
