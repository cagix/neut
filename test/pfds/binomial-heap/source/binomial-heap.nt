data tree(a) {
  // the list is in decreasing order of rank
- Node(int, a, list(tree(a)))
}

data heap(a: tau) {
- Heap(list(tree(a)))
}

data order {
- LT
- EQ
- GT
}

define join(a: tau, cmp: (a, a) -> order, t1: tree(a), t2: tree(a)): tree(a) {
  match t1, t2 {
  - Node(r1, x1, children1), Node(r2, x2, children2) =>
    match cmp(x1, x2) {
    - LT =>
      Node(add-int(r1, 1), x1, Node(r2, x2, children2) :: children1)
    - _ =>
      Node(add-int(r1, 1), x2, Node(r1, x1, children1) :: children2)
    }
  }
}

define rank(a: tau, t: &tree(a)): int {
  case t {
  - Node(r, _, _) =>
    *r
  }
}

define _insert-tree(a: tau, cmp: (a, a) -> order, t: tree(a), h: list(tree(a))): list(tree(a)) {
  match h {
  - [] =>
    [t]
  - t1 :: rest =>
    let r on t = rank(a, t) in
    let r1 on t1 = rank(a, t1) in
    if lt-int(r, r1) {
      t :: t1 :: rest
    } else {
      _insert-tree(a, cmp, join(a, cmp, t, t1), rest)
    }
  }
}

define insert(a: tau, cmp: (a, a) -> order, value: a, h: heap(a)): heap(a) {
  let Heap(ts) = h in
  Heap(_insert-tree(a, cmp, Node(0, value, []), ts))
}

define merge(a: tau, cmp: (a, a) -> order, h1: heap(a), h2: heap(a)): heap(a) {
  let Heap(ts1) = h1 in
  let Heap(ts2) = h2 in
  Heap(_merge(a, cmp, ts1, ts2))
}

define _merge(a: tau, cmp: (a, a) -> order, h1: list(tree(a)), h2: list(tree(a))): list(tree(a)) {
  match h1, h2 {
  - [], h2 =>
    h2
  - h1, [] =>
    h1
  - t1 :: ts1, t2 :: ts2 =>
    let r1 on t1 = rank(a, t1) in
    let r2 on t2 = rank(a, t2) in
    if lt-int(r1, r2) {
      t1 :: _merge(a, cmp, ts1, t2 :: ts2)
    } else-if gt-int(r1, r2) {
      t2 :: _merge(a, cmp, t1 :: ts1, ts2)
    } else {
      _insert-tree(a, cmp, join(a, cmp, t1, t2), _merge(a, cmp, ts1, ts2))
    }
  }
}


define root(a: tau, t: &tree(a)): a {
  case t {
  - Node(_, v, _) =>
    *v
  }
}

define find-min(a: tau, cmp: (a, a) -> order, h: &heap(a)): ?a {
  let helper =
    mu self(cand: a, h: &list(tree(a))): a {
      case h {
      - [] =>
        cand
      - t :: ts =>
        let root-head = root(a, t) in
        match cmp(root-head, cand) {
        - LT =>
          self(root-head, ts)
        - _ =>
          self(cand, ts)
        }
      }
    }
  in
  case h {
  - Heap([]) =>
    none()
  - Heap(t :: ts) =>
    let r = root(a, t) in
    Pass(helper(r, ts))
  }
}

define remove-min-tree(a: tau, cmp: (a, a) -> order, h: heap(a)): ?tuple(tree(a), heap(a)) {
  match h {
  - Heap([]) =>
    none()
  - Heap([t]) =>
    Pass(Tuple(t, Heap([])))
  - Heap(t :: ts) =>
    try Tuple(cand, Heap(ts-adjusted)) = remove-min-tree(a, cmp, Heap(ts)) in
    let c on t, cand =
      let root-head = root(a, t) in
      let root-cand = root(a, cand) in
      cmp(root-head, root-cand)
    in
    match c {
    - LT =>
      Pass(Tuple(t, Heap(cand :: ts-adjusted)))
    - _ =>
      Pass(Tuple(cand, Heap(t :: ts-adjusted)))
    }
  }
}

define delete-min(a: tau, cmp: (a, a) -> order, h: heap(a)): ?heap(a) {
  try Tuple(Node(_, _, ts1), ts2): tuple(tree(a), heap(a)) = remove-min-tree(a, cmp, h) in
  Pass(merge(a, cmp, Heap(reverse(ts1)), ts2))
}

define compare-int(x: int, y: int): order {
  if lt-int(x, y) {
    LT
  } else-if gt-int(x, y) {
    GT
  } else {
    EQ
  }
}

define main(): unit {
  let h: heap(int) = Heap([]) in
  let h = insert(int, compare-int, 3, h) in
  let h = insert(int, compare-int, 4, h) in
  let h = insert(int, compare-int, 2, h) in
  let h = insert(int, compare-int, 9, h) in
  let h = insert(int, compare-int, 100, h) in
  let h = insert(int, compare-int, 8, h) in
  let h = insert(int, compare-int, 1, h) in
  let h = merge(int, compare-int, h, h) in
  let maybe-min on h =
    match find-min(int, compare-int, h) {
    - Fail(_) =>
      10
    - Pass(min) =>
      min
    }
  in
  let _ = h in
  print-int(maybe-min);
  print("\n")
}
