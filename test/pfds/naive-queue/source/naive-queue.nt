import {
- core.either => S
- core.text => T
}

define-inline queue(a: tau): tau {
  tuple(list(a), list(a))
}

define empty[a](): queue(a) {
  Tuple([], [])
}

define head[a](q: &queue(a)): ?a {
  case q {
  - Tuple(x :: _, _) =>
    Some(*x)
  - _ =>
    None
  }
}

define-inline sanitize[a](q: queue(a)): queue(a) {
  match q {
  - Tuple([], ys) =>
    Tuple(reverse(ys), [])
  - q =>
    q
  }
}

define tail[a](q: queue(a)): ?queue(a) {
  match q {
  - Tuple(_ :: rest, ys) =>
    Some(sanitize(Tuple(rest, ys)))
  - _ =>
    None
  }
}

define snoc[a](v: a, q: queue(a)): queue(a) {
  let Tuple(xs, ys) = q
  sanitize(Tuple(xs, v :: ys))
}

define sum(xs: &list(int)): int {
  case xs {
  - [] =>
    0
  - v :: rest =>
    add-int(*v, sum(rest))
  }
}

define main(): unit {
  let q: queue(list(int)) = empty()
  let q = snoc([2], q)
  let q = snoc([5], q)
  let q = snoc([1], q)
  // v1 == 2
  let v1 on q = {
    match head(q) {
    - Some(xs1) =>
      let v1 on xs1 = sum(xs1)
      let _ = xs1
      v1
    - None =>
      4
    }
  }
  let mq = tail(q)
  let result =
    match mq {
    - None =>
      1
    - Some(q) =>
      let q = snoc([3], q)
      let q = snoc([8], q)
      // v2 = 5
      let v2 on q = {
        match head(q) {
        - Some(xs) =>
          let v on xs = sum(xs)
          let _ = xs
          v
        - None =>
          4
        }
      }
      let _ = q
      // 2 + 5 = 7
      add-int(v1, v2)
    }
  print-int(result)
  print("\n")
}
