import {
- core.list
- core.bool
- core.option
- core.sum => S
- core.text => T
}

define-inline queue(a: tau): tau {
  list(a) * list(a)
}

define empty[a](): queue(a) {
  tuple([], [])
}

define head[a](q: &queue(a)): ?a {
  case q {
  - tuple(x :< _, _) =>
    Some(!x)
  - _ =>
    None
  }
}

define-inline sanitize[a](q: queue(a)): queue(a) {
  match q {
  - tuple([], ys) =>
    tuple(reverse(ys), [])
  - q =>
    q
  }
}

define tail[a](q: queue(a)): ?queue(a) {
  match q {
  - tuple(_ :< rest, ys) =>
    Some(sanitize(tuple(rest, ys)))
  - _ =>
    None
  }
}

define snoc[a](v: a, q: queue(a)): queue(a) {
  let tuple(xs, ys) = q
  sanitize(tuple(xs, v :< ys))
}

define sum(xs: &list(int)): int {
  case xs {
  - [] =>
    0
  - v :< rest =>
    add-int(!v, sum(rest))
  }
}

define main(): unit {
  let q: queue(list(int)) = empty()
  let q = snoc([2], q)
  let q = snoc([5], q)
  let q = snoc([1], q)
  // v1 == 2
  let v1 on q = {
    match head(q) {
    - Some(xs1) =>
      let v1 on xs1 = sum(xs1)
      let _ = xs1
      v1
    - None =>
      4
    }
  }
  let mq = tail(q)
  let result =
    match mq {
    - None =>
      1
    - Some(q) =>
      let q = snoc([3], q)
      let q = snoc([8], q)
      // v2 = 5
      let v2 on q = {
        match head(q) {
        - Some(xs) =>
          let v on xs = sum(xs)
          let _ = xs
          v
        - None =>
          4
        }
      }
      let _ = q
      // 2 + 5 = 7
      add-int(v1, v2)
    }
  print-int(result)
  print("\n")
}
