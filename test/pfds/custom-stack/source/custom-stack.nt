import {
- core.bool
- core.top
- core.option
- core.list => L
- core.text => T
}

variant custom-stack(a) {
- Nil
- Cons(product(a, a), custom-stack(a))
}

define empty[a](): custom-stack(a) {
  Nil
}

define is-empty[a](xs: &custom-stack(a)): bool {
  case xs {
  - Nil =>
    True
  - Cons(_, _) =>
    False
  }
}

define head[a](xs: &custom-stack(a)): ?&{a * a} {
  case xs {
  - Nil =>
    None
  - Cons(a, _) =>
    Some(a)
  }
}

define tail[a](xs: &custom-stack(a)): ?&custom-stack(a) {
  case xs {
  - Nil =>
    None
  - Cons(_, rest) =>
    Some(rest)
  }
}

define main(): int {
  let xs = empty()
  let v = tuple(lambda () { 1 }, lambda () { 2: int })
  let ys = Cons(v, xs)
  let zs = Cons(v, Cons(v, ys))
  let calc on zs, xs = {
    let _ = is-empty(zs)
    let _ = is-empty(xs)
    let h = head(zs)
    let _ = head(xs)
    let _ = tail(zs)
    let _ = tail(zs)
    match h {
    - None =>
      1
    - Some(pair) =>
      bind tuple(_, right) = pair
      {!right}()
    }
  }
  let _ = zs
  let _ = xs
  let _ = calc
  0
}
