import {
- core.bool
- core.text => T
}

data order {
- LT
- EQ
- GT
}

data set(a) {
- Leaf
- Node(set(a), a, set(a))
}

data set-signature(a) {
- Set(
    empty: set(a),
    insert: (a, set(a)) -> set(a),
    member: (a, &set(a)) -> bool
  )
}

define make-set-signature[a](compare: (a, a) -> order): set-signature(a) {
  Set of {
  - empty =>
    Leaf
  - insert =>
    mu insert(new-value: a, haystack: set(a)): set(a) {
      match haystack {
      - Leaf =>
        Node(Leaf, new-value, Leaf)
      - Node(left, x, right) =>
        match compare(new-value, x) {
        - LT =>
          Node(insert(new-value, left), x, right)
        - EQ =>
          Node(left, x, right)
        - GT =>
          Node(left, x, insert(new-value, right))
        }
      }
    }
  - member =>
    mu member(needle: a, haystack: &set(a)) {
      case haystack {
      - Leaf =>
        False
      - Node(left, x, right) =>
        match compare(needle, *x) {
        - LT =>
          member(needle, left)
        - EQ =>
          True
        - GT =>
          member(needle, right)
        }
      }
    }
  }
}

define compare-int(x: int, y: int): order {
  if lt-int(x, y) {
    LT
  } else-if gt-int(x, y) {
    GT
  } else {
    EQ
  }
}

define main(): unit {
  let int-set-signature = make-set-signature(compare-int)
  match int-set-signature {
  - Set(..) =>
    let my-set = insert(10, empty)
    let my-set = insert(20, my-set)
    let my-set = insert(20, my-set)
    let my-set = insert(20, my-set)
    let my-set = insert(30, my-set)
    let result on my-set = member(5, my-set)
    let _ = my-set
    if result {
      print-int(1)
    } else {
      print-int(2)
    }
  }
  print("\n")
}
