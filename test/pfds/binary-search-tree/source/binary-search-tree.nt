import {
- core.bool
}

use {
- core.bool
- this.binary-search-tree::set
}

variant order() {
- LT()
- EQ()
- GT()
}

variant set(a) {
- Leaf()
- Node(set(a), a, set(a))
}

struct set-signature(a) {
- empty: set(a)
- insert: (a, set(a)) -> set(a)
- member: (a, &set(a)) -> bool()
}

define make-set-signature<a>(compare: (a, a) -> order()): set-signature(a) {
  new set-signature {
  - set-signature.empty <=
    set.Leaf()
  - set-signature.insert <=
    define insert(new-value: a, haystack: set(a)): set(a) {
      match haystack {
      - set.Leaf() =>
        set.Node(Leaf(), new-value, Leaf())
      - Node(left, x, right) =>
        match compare(new-value, x) {
        - order.LT() =>
          Node(insert(new-value, left), x, right)
        - order.EQ() =>
          Node(left, x, right)
        - order.GT() =>
          Node(left, x, insert(new-value, right))
        }
      }
    }
  - set-signature.member <=
    define member(needle: a, haystack: &set(a)) {
      case haystack {
      - set.Leaf() =>
        bool.False()
      - set.Node(left, x, right) =>
        match compare(needle, !x) {
        - order.LT() =>
          member(needle, left)
        - order.EQ() =>
          bool.True()
        - order.GT() =>
          member(needle, right)
        }
      }
    }
  }
}

define compare-int(x: i64, y: i64): order() {
  if lt-i64(x, y) {
    order.LT()
  } else-if gt-i64(x, y) {
    order.GT()
  } else {
    order.EQ()
  }
}

define main(): i64 {
  let int-set-signature = make-set-signature(compare-int)
  match int-set-signature {
  - set-signature.New(empty, insert, member) =>
    let my-set = insert(10, empty)
    let my-set = insert(20, my-set)
    let my-set = insert(20, my-set)
    let my-set = insert(20, my-set)
    let my-set = insert(30, my-set)
    let result on my-set = member(5, my-set)
    if result {
      1
    } else {
      2
    }
  }
}
