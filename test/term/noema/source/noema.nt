import {
- core
}

define test-syntax(): unit {
  let _ = &list(tau) in
  let _ = &list(&list(tau)) in
  let _ = (&tau, &list((&list(tau)) -> &list(tau))) -> &list(tau) in
  let xs: list(int) = [1, 2, 3] in
  let _ on xs =
    let _ on xs =
      let l1 = length(*xs) in
      let l2 = length(*xs) in
      add-int(l1, l2)
    in
    let _ = length(xs) in
    let xs-copy = *xs in
    let _ = xs in
    let _ = xs in
    let _ = xs in
    let _ = xs-copy in
    let _ = xs-copy in
    let _ = xs-copy in
    case xs {
    - Nil =>
      length(xs)
    - Cons(_, ys) =>
      length(ys)
    }
  in
  let _ = xs in
  let ys = xs in
  let zs = xs in
  let _ on xs, ys, zs =
    let v1 = length(xs) in
    let v2 = length(ys) in
    let v3 = length(zs) in
    add-int(v1, add-int(v2, v3))
  in
  let _ = xs in
  let _ = ys in
  let _ = zs in
  Unit
}

data term(a) {
- Var(a)
- Abs(a, term(a))
- App(term(a), term(a))
}

data my-enum {
- Foo
- Bar
}

define nested-enum-match(t: &term(my-enum)): term(my-enum) {
  let val =
    case t {
    - App(Abs(x, t'), Var(e)) =>
      let _ = Var(e) in
      let t' = *t' in
      let _ = t' in
      let _ = x in
      let _ = Var(e) in
      let _ = t' in
      let _ = x in
      let _ = Var(e) in
      let _ = t' in
      let _ = x in
      let _ = Var(e) in
      let _ = x in
      let _ = Var(e) in
      let _ = x in
      Bar
    - App(Abs(x, _), App(Var(_), App(_, App(w, _)))) =>
      let foo = *w in
      let _ = foo in
      let _ = foo in
      let _ = foo in
      let _ = foo in
      let _ = x in
      Foo
    - App(Abs(_, _), App(App(_, App(_, _)), Var(_))) =>
      Bar
    - App(App(Abs(_, _), Var(_)), App(App(Abs(_, _), App(_, _)), Var(_))) =>
      Foo
    - App(App(Abs(_, _), Var(_)), App(App(_, App(_, _)), Var(_))) =>
      Bar
    - t =>
      let t = *t in
      let _ = t in
      let _ = t in
      let _ = t in
      Foo
    }
  in
  match val {
  - Foo =>
    let _ = val in
    *t
  - Bar =>
    *t
  }
}

define unbalanced-freevars-in-branches(a: tau, t: &term(a)): term(a) {
  let foo = Var("test") in
  let f =
    () => {
      foo
    }
  in
  let g =
    () => {
      foo
    }
  in
  let h =
    () => {
      foo
    }
  in
  case t {
  - Var(x) =>
    let _ = f in
    case t {
    - Var(_) =>
      let _ = g in
      let _ = x in
      *t
    - Abs(_, t) =>
      let val = *t in
      let _ = val in
      let _ = val in
      let _ = val in
      let _ = val in
      val
    - _ =>
      *t
    }
  - Abs(_, t) =>
    case t {
    - App(_, e2) =>
      *e2
    - _ =>
      let _ = t in
      let _ = t in
      *t
    }
  - App(t1, _) =>
    let _ = g in
    let k =
      if False {
        h
      } else {
        () => {
          Var("pohe")
        }
      }
    in
    let _ = k in
    let _ = k in
    let _ = k in
    *t1
  }
}

data ctx {
- Ctx(counter: cell(int))
}

define with-ctx(c: &ctx): unit {
  tie Ctx(counter) = c in
  let current-value = clone(counter) in
  if eq-int(current-value, 0) {
    print("stop\n")
  } else {
    print("loop\n");
    mutate(counter, (x) => {
      sub-int(x, 1)
    });
    with-ctx(c)
  }
}

define test-resource(): unit {
  let t1 = Var(Foo) in
  let t2 = Abs(Bar, Var(Bar)) in
  let t3 = App(Abs(Bar, Var(Bar)), Var(Foo)) in
  let t4 = Abs(Bar, App(Var(Bar), Var(Bar))) in
  let _ on t1 = nested-enum-match(t1) in
  let _ on t2 = nested-enum-match(t2) in
  let _ on t3 = nested-enum-match(t3) in
  let _ on t4 = nested-enum-match(t4) in
  let _ on t1 = unbalanced-freevars-in-branches(_, t1) in
  let _ on t2 = unbalanced-freevars-in-branches(_, t2) in
  let _ on t3 = unbalanced-freevars-in-branches(_, t3) in
  let _ on t4 = unbalanced-freevars-in-branches(_, t4) in
  let _ = t1 in
  let _ = t2 in
  let _ = t3 in
  let _ = t4 in
  let c = Ctx(new-cell(5)) in
  let _ on c = with-ctx(c) in
  let _ = c in
  Unit
}

define main(): unit {
  test-syntax();
  test-resource();
  Unit
}
