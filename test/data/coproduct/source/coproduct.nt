import {
- core.sum
- core.bool
}

use {
- core.sum
- core.sum::sum
- this.coproduct::nat
}

enum nat() {
- zero()
- succ(nat())
}

define interpret(n: nat()): i64 {
  match n {
  - nat.zero() =>
    0
  - nat.succ(m) =>
    add-i64(1, interpret(m))
  }
}

define view(a: tau, b: tau, x: sum(a, b)): i64 {
  match x {
  - left(c) =>
    1
  - right(d) =>
    2
  }
}

define computation-with-error(x: i64): sum(nat(), i64) {
  if eq-i64(x, 0) {
    left(succ(zero()))
  } else {
    right(interpret(succ(succ(zero()))))
  }
}

define let-sum(x: i64): sum(nat(), i64) {
  let? foo = computation-with-error(x)
  let? bar = computation-with-error(add-i64(foo, 1))
  right(bar)
}

define main(): i64 {
  match let-sum(10) {
  - left(e) =>
    interpret(e)
  - right(v) =>
    let x = view(i64, i32, left(10))
    let y = view(i64, i32, right(10))
    let z = x
    let w = x
    add-i64(v, 1)
  }
}
