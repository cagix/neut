use {
- this.fold-tails::list
- this.fold-tails::nat
}

enum nat() {
- zero()
- succ(nat())
}

enum list(a: tau) {
- nil()
- cons(a, list(a))
}

define add-nat(x: nat(), y: nat()): nat() {
  match x {
  - zero() =>
    y
  - succ(m) =>
    add-nat(m, succ(y))
  }
}

define mul-nat(x: nat(), y: nat()): nat() {
  match x {
  - zero() =>
    zero()
  - succ(m) =>
    add-nat(mul-nat(m, y), y)
  }
}

define interpret(n: nat()): i64 {
  match n {
  - zero() =>
    0
  - succ(m) =>
    add-i64(1, interpret(m))
  }
}

define gen(n: nat()): list(nat()) {
  match n {
  - zero() =>
    nil()
  - succ(m) =>
    cons(n, gen(m))
  }
}

define fold-r(a: tau, b: tau, f: (b, a) -> a, acc: a, xs: list(b)): a {
  match xs {
  - nil() =>
    acc
  - cons(y, ys) =>
    f(y, fold-r(a, b, f, acc, ys))
  }
}

define tails(a: tau, xs: list(a)): list(list(a)) {
  match xs {
  - nil() =>
    cons(nil(), nil())
  - cons(x, xs) =>
    cons(xs, tails(a, xs))
  }
}

define map(a: tau, b: tau, f: a -> b, xs: list(a)): list(b) {
  match xs {
  - nil() =>
    nil()
  - cons(y, ys) =>
    cons(f(y), map(a, b, f, ys))
  }
}

define head(xs: list(nat())): nat() {
  match xs {
  - nil() =>
    zero()
  - cons(y, ys) =>
    y
  }
}

define main(): i64 {
  let n = succ(succ(succ(zero())))
  let n-copy1 = n
  let n-copy2 = n
  let n-copy3 = n
  let m = mul-nat(n, mul-nat(n, n))
  let m-copy1 = m
  let m-copy2 = m
  let xs = gen(m)
  let yss = tails(_, xs)
  let yss-copy1 = yss
  let yss-copy2 = yss
  let zs = map(_, _, lambda (l) { head(l) }, yss)
  let zs-copy1 = zs
  let zs-copy2 = zs
  let zs-copy3 = zs
  let zs-copy4 = zs
  let zs-copy5 = zs
  let result-nat = fold-r(_, _, lambda (a, b) { add-nat(a, b) }, zero(), zs)
  let result-nat-copy1 = result-nat
  let result-nat-copy2 = result-nat
  let result = interpret(result-nat)
  result
}
