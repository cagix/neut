variant nat {
- Zero
- Succ(nat)
}

variant list(a: tau) {
- Nil()
- Cons(a, list(a))
}

define add-nat(x: nat, y: nat): nat {
  match x {
  - Zero =>
    y
  - Succ(m) =>
    add-nat(m, Succ(y))
  }
}

define mul-nat(x: nat, y: nat): nat {
  match x {
  - Zero =>
    Zero
  - Succ(m) =>
    add-nat(mul-nat(m, y), y)
  }
}

define interpret(n: nat): i64 {
  match n {
  - Zero =>
    0
  - Succ(m) =>
    add-i64(1, interpret(m))
  }
}

define gen(n: nat): list(nat) {
  match n {
  - Zero =>
    Nil()
  - Succ(m) =>
    Cons(n, gen(m))
  }
}

define fold-r(a: tau, b: tau, f: (b, a) -> a, acc: a, xs: list(b)): a {
  match xs {
  - Nil() =>
    acc
  - Cons(y, ys) =>
    f(y, fold-r(a, b, f, acc, ys))
  }
}

define tails(a: tau, xs: list(a)): list(list(a)) {
  match xs {
  - Nil() =>
    Cons(Nil(), Nil())
  - Cons(x, xs) =>
    Cons(xs, tails(a, xs))
  }
}

define map(a: tau, b: tau, f: a -> b, xs: list(a)): list(b) {
  match xs {
  - Nil() =>
    Nil()
  - Cons(y, ys) =>
    Cons(f(y), map(a, b, f, ys))
  }
}

define head(xs: list(nat)): nat {
  match xs {
  - Nil() =>
    Zero
  - Cons(y, ys) =>
    y
  }
}

define main(): i64 {
  let n = Succ(Succ(Succ(Zero)))
  let n-copy1 = n
  let n-copy2 = n
  let n-copy3 = n
  let m = mul-nat(n, mul-nat(n, n))
  let m-copy1 = m
  let m-copy2 = m
  let xs = gen(m)
  let yss = tails(_, xs)
  let yss-copy1 = yss
  let yss-copy2 = yss
  let zs = map(_, _, lambda (l) { head(l) }, yss)
  let zs-copy1 = zs
  let zs-copy2 = zs
  let zs-copy3 = zs
  let zs-copy4 = zs
  let zs-copy5 = zs
  let result-nat = fold-r(_, _, lambda (a, b) { add-nat(a, b) }, Zero, zs)
  let result-nat-copy1 = result-nat
  let result-nat-copy2 = result-nat
  let result = interpret(result-nat)
  result
}
