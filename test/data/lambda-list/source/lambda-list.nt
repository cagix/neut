use {
- this.lambda-list::list
- this.lambda-list::nat
}

enum nat() {
- zero()
- succ(nat())
}

define interpret(n: nat()): i64 {
  match n {
  - zero() =>
    0
  - succ(m) =>
    add-i64(1, interpret(m))
  }
}

define add-nat(x: nat(), y: nat()): nat() {
  match x {
  - zero() =>
    y
  - succ(m) =>
    add-nat(m, succ(y))
  }
}

define mul-nat(x: nat(), y: nat()): nat() {
  match x {
  - zero() =>
    zero()
  - succ(m) =>
    add-nat(mul-nat(m, y), y)
  }
}

enum list(a: tau) {
- nil()
- cons(a, list(a))
}

define fold(a: tau, fs: list(a -> a), x: a): a {
  match fs {
  - nil() =>
    x
  - cons(f, rest) =>
    let yo = rest
    let hey = rest
    f(fold(a, rest, x))
  }
}

define main(): i64 {
  let n1 = succ(zero())
  let n2 = succ(n1)
  let n3 = succ(n2)
  let add2 = lambda (x) { add-nat(x, n2) }
  let mul3 = lambda (x) { mul-nat(x, n3) }
  let mul9 = lambda (x) { mul-nat(x, mul-nat(n3, n3)) }
  let mul9-unused = mul9
  // let mul9-unused2 = mul9

  // let add2 = lambda (x). add-i64(x, 2)
  // let mul3 = lambda (x). mul-i64(x, 3)
  // let sub1 = lambda (x). sub-i64(x, 1)
  let fs = cons(add2, cons(mul3, cons(mul9, nil())))
  let gs = fs
  let hs = gs
  interpret(fold(_, hs, n3))
  // fold(hs, 10)
}
